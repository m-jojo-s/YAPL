Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> S
Rule 1     S -> stmt S
Rule 2     S -> <empty>
Rule 3     stmt -> exp SEMICOL
Rule 4     stmt -> SEMICOL
Rule 5     stmt -> L_ROUND R_ROUND
Rule 6     stmt -> L_CURLY R_CURLY
Rule 7     stmt -> L_SQR R_SQR
Rule 8     stmt_blk -> L_CURLY S R_CURLY
Rule 9     stmt -> PRINT L_ROUND args R_ROUND SEMICOL
Rule 10    args -> args COMMA args
Rule 11    args -> exp
Rule 12    args -> <empty>
Rule 13    stmt -> if
Rule 14    if -> IF L_ROUND exp R_ROUND stmt_blk else
Rule 15    else -> ELSE stmt_blk
Rule 16    else -> ELSE if
Rule 17    else -> <empty>
Rule 18    stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk
Rule 19    stmt -> STRUCT VAR_NAME dec_blk
Rule 20    stmt -> VAR_NAME VAR_NAME SEMICOL
Rule 21    stmt -> declare
Rule 22    stmt -> dec_blk
Rule 23    dec_blk -> L_CURLY declare R_CURLY
Rule 24    declare -> dec declare
Rule 25    declare -> <empty>
Rule 26    dec -> DATA_TYPE VAR_NAME SEMICOL
Rule 27    dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL
Rule 28    stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk
Rule 29    param_blk -> L_ROUND param R_ROUND
Rule 30    param -> param COMMA param
Rule 31    param -> DATA_TYPE VAR_NAME
Rule 32    param -> <empty>
Rule 33    stmt -> RETURN exp SEMICOL
Rule 34    stmt -> RETURN SEMICOL
Rule 35    stmt -> VAR_NAME ASSIGNMENT exp SEMICOL
Rule 36    stmt -> exp ASSIGNMENT exp SEMICOL
Rule 37    exp -> L_ROUND exp R_ROUND
Rule 38    exp -> L_CURLY exp R_CURLY
Rule 39    exp -> L_SQR exp R_SQR
Rule 40    exp -> exp PLUS exp
Rule 41    exp -> exp MINUS exp
Rule 42    exp -> exp ASTERISK exp
Rule 43    exp -> exp FWSLASH exp
Rule 44    exp -> exp TOPI exp
Rule 45    exp -> exp MOD exp
Rule 46    exp -> exp LESSER exp
Rule 47    exp -> exp GREATER exp
Rule 48    exp -> exp LESSER_EQUAL exp
Rule 49    exp -> exp GREATER_EQUAL exp
Rule 50    exp -> exp IS_EQUAL exp
Rule 51    exp -> exp NOT_EQUAL exp
Rule 52    exp -> exp LOGICAL exp
Rule 53    exp -> exp DOT VAR_NAME
Rule 54    exp -> VAR_NAME L_ROUND args R_ROUND
Rule 55    exp -> MINUS exp
Rule 56    exp -> NOT exp
Rule 57    exp -> VAR_NAME PLUS_PLUS
Rule 58    exp -> VAR_NAME MINUS_MINUS
Rule 59    exp -> VAR_NAME
Rule 60    exp -> INT
Rule 61    exp -> FLOAT
Rule 62    exp -> STRING
Rule 63    exp -> CHAR
Rule 64    exp -> BOOL

Terminals, with rules where they appear

ASSIGNMENT           : 27 35 36
ASTERISK             : 42
BOOL                 : 64
CHAR                 : 63
COMMA                : 10 30
DATA_TYPE            : 26 27 31
DOT                  : 53
ELSE                 : 15 16
FLOAT                : 61
FOR                  : 18
FUNC_DEC             : 28
FWSLASH              : 43
GREATER              : 47
GREATER_EQUAL        : 49
IF                   : 14
INT                  : 60
IS_EQUAL             : 50
LESSER               : 46
LESSER_EQUAL         : 48
LOGICAL              : 52
L_CURLY              : 6 8 23 38
L_ROUND              : 5 9 14 18 29 37 54
L_SQR                : 7 39
MINUS                : 41 55
MINUS_MINUS          : 58
MOD                  : 45
NOT                  : 56
NOT_EQUAL            : 51
PLUS                 : 40
PLUS_PLUS            : 57
PRINT                : 9
RETURN               : 33 34
R_CURLY              : 6 8 23 38
R_ROUND              : 5 9 14 18 29 37 54
R_SQR                : 7 39
SEMICOL              : 3 4 9 18 20 26 27 33 34 35 36
STRING               : 62
STRUCT               : 19
TOPI                 : 44
VAR_NAME             : 19 20 20 26 27 28 31 35 53 54 57 58 59
error                : 

Nonterminals, with rules where they appear

S                    : 1 8 0
args                 : 9 10 10 54
dec                  : 24
dec_blk              : 19 22
declare              : 21 23 24
else                 : 14
exp                  : 3 11 14 18 27 33 35 36 36 37 38 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 55 56
if                   : 13 16
param                : 29 30 30
param_blk            : 28
stmt                 : 1 18 18
stmt_blk             : 14 15 18 28

Parsing method: LALR

state 0

    (0) S' -> . S
    (1) S -> . stmt S
    (2) S -> .
    (3) stmt -> . exp SEMICOL
    (4) stmt -> . SEMICOL
    (5) stmt -> . L_ROUND R_ROUND
    (6) stmt -> . L_CURLY R_CURLY
    (7) stmt -> . L_SQR R_SQR
    (9) stmt -> . PRINT L_ROUND args R_ROUND SEMICOL
    (13) stmt -> . if
    (18) stmt -> . FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk
    (19) stmt -> . STRUCT VAR_NAME dec_blk
    (20) stmt -> . VAR_NAME VAR_NAME SEMICOL
    (21) stmt -> . declare
    (22) stmt -> . dec_blk
    (28) stmt -> . FUNC_DEC VAR_NAME param_blk stmt_blk
    (33) stmt -> . RETURN exp SEMICOL
    (34) stmt -> . RETURN SEMICOL
    (35) stmt -> . VAR_NAME ASSIGNMENT exp SEMICOL
    (36) stmt -> . exp ASSIGNMENT exp SEMICOL
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL
    (14) if -> . IF L_ROUND exp R_ROUND stmt_blk else
    (24) declare -> . dec declare
    (25) declare -> .
    (23) dec_blk -> . L_CURLY declare R_CURLY
    (26) dec -> . DATA_TYPE VAR_NAME SEMICOL
    (27) dec -> . DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL

  ! shift/reduce conflict for SEMICOL resolved as shift
  ! shift/reduce conflict for L_ROUND resolved as shift
  ! shift/reduce conflict for L_CURLY resolved as shift
  ! shift/reduce conflict for L_SQR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRUCT resolved as shift
  ! shift/reduce conflict for VAR_NAME resolved as shift
  ! shift/reduce conflict for FUNC_DEC resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 2 (S -> .)
  ! shift/reduce conflict for DATA_TYPE resolved as shift
    $end            reduce using rule 2 (S -> .)
    SEMICOL         shift and go to state 4
    L_ROUND         shift and go to state 5
    L_CURLY         shift and go to state 6
    L_SQR           shift and go to state 7
    PRINT           shift and go to state 8
    FOR             shift and go to state 10
    STRUCT          shift and go to state 11
    VAR_NAME        shift and go to state 12
    FUNC_DEC        shift and go to state 15
    RETURN          shift and go to state 16
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23
    IF              shift and go to state 24
    DATA_TYPE       shift and go to state 26

  ! SEMICOL         [ reduce using rule 25 (declare -> .) ]
  ! L_ROUND         [ reduce using rule 25 (declare -> .) ]
  ! L_CURLY         [ reduce using rule 25 (declare -> .) ]
  ! L_SQR           [ reduce using rule 25 (declare -> .) ]
  ! PRINT           [ reduce using rule 25 (declare -> .) ]
  ! FOR             [ reduce using rule 25 (declare -> .) ]
  ! STRUCT          [ reduce using rule 25 (declare -> .) ]
  ! VAR_NAME        [ reduce using rule 25 (declare -> .) ]
  ! FUNC_DEC        [ reduce using rule 25 (declare -> .) ]
  ! RETURN          [ reduce using rule 25 (declare -> .) ]
  ! MINUS           [ reduce using rule 25 (declare -> .) ]
  ! NOT             [ reduce using rule 25 (declare -> .) ]
  ! INT             [ reduce using rule 25 (declare -> .) ]
  ! FLOAT           [ reduce using rule 25 (declare -> .) ]
  ! STRING          [ reduce using rule 25 (declare -> .) ]
  ! CHAR            [ reduce using rule 25 (declare -> .) ]
  ! BOOL            [ reduce using rule 25 (declare -> .) ]
  ! IF              [ reduce using rule 25 (declare -> .) ]
  ! DATA_TYPE       [ reduce using rule 25 (declare -> .) ]
  ! $end            [ reduce using rule 25 (declare -> .) ]

    S                              shift and go to state 1
    stmt                           shift and go to state 2
    exp                            shift and go to state 3
    if                             shift and go to state 9
    dec_blk                        shift and go to state 13
    declare                        shift and go to state 14
    dec                            shift and go to state 25

state 1

    (0) S' -> S .



state 2

    (1) S -> stmt . S
    (1) S -> . stmt S
    (2) S -> .
    (3) stmt -> . exp SEMICOL
    (4) stmt -> . SEMICOL
    (5) stmt -> . L_ROUND R_ROUND
    (6) stmt -> . L_CURLY R_CURLY
    (7) stmt -> . L_SQR R_SQR
    (9) stmt -> . PRINT L_ROUND args R_ROUND SEMICOL
    (13) stmt -> . if
    (18) stmt -> . FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk
    (19) stmt -> . STRUCT VAR_NAME dec_blk
    (20) stmt -> . VAR_NAME VAR_NAME SEMICOL
    (21) stmt -> . declare
    (22) stmt -> . dec_blk
    (28) stmt -> . FUNC_DEC VAR_NAME param_blk stmt_blk
    (33) stmt -> . RETURN exp SEMICOL
    (34) stmt -> . RETURN SEMICOL
    (35) stmt -> . VAR_NAME ASSIGNMENT exp SEMICOL
    (36) stmt -> . exp ASSIGNMENT exp SEMICOL
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL
    (14) if -> . IF L_ROUND exp R_ROUND stmt_blk else
    (24) declare -> . dec declare
    (25) declare -> .
    (23) dec_blk -> . L_CURLY declare R_CURLY
    (26) dec -> . DATA_TYPE VAR_NAME SEMICOL
    (27) dec -> . DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL

  ! shift/reduce conflict for SEMICOL resolved as shift
  ! shift/reduce conflict for L_ROUND resolved as shift
  ! shift/reduce conflict for L_CURLY resolved as shift
  ! shift/reduce conflict for L_SQR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRUCT resolved as shift
  ! shift/reduce conflict for VAR_NAME resolved as shift
  ! shift/reduce conflict for FUNC_DEC resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 2 (S -> .)
  ! reduce/reduce conflict for R_CURLY resolved using rule 2 (S -> .)
  ! shift/reduce conflict for DATA_TYPE resolved as shift
    $end            reduce using rule 2 (S -> .)
    R_CURLY         reduce using rule 2 (S -> .)
    SEMICOL         shift and go to state 4
    L_ROUND         shift and go to state 5
    L_CURLY         shift and go to state 6
    L_SQR           shift and go to state 7
    PRINT           shift and go to state 8
    FOR             shift and go to state 10
    STRUCT          shift and go to state 11
    VAR_NAME        shift and go to state 12
    FUNC_DEC        shift and go to state 15
    RETURN          shift and go to state 16
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23
    IF              shift and go to state 24
    DATA_TYPE       shift and go to state 26

  ! SEMICOL         [ reduce using rule 25 (declare -> .) ]
  ! L_ROUND         [ reduce using rule 25 (declare -> .) ]
  ! L_CURLY         [ reduce using rule 25 (declare -> .) ]
  ! L_SQR           [ reduce using rule 25 (declare -> .) ]
  ! PRINT           [ reduce using rule 25 (declare -> .) ]
  ! FOR             [ reduce using rule 25 (declare -> .) ]
  ! STRUCT          [ reduce using rule 25 (declare -> .) ]
  ! VAR_NAME        [ reduce using rule 25 (declare -> .) ]
  ! FUNC_DEC        [ reduce using rule 25 (declare -> .) ]
  ! RETURN          [ reduce using rule 25 (declare -> .) ]
  ! MINUS           [ reduce using rule 25 (declare -> .) ]
  ! NOT             [ reduce using rule 25 (declare -> .) ]
  ! INT             [ reduce using rule 25 (declare -> .) ]
  ! FLOAT           [ reduce using rule 25 (declare -> .) ]
  ! STRING          [ reduce using rule 25 (declare -> .) ]
  ! CHAR            [ reduce using rule 25 (declare -> .) ]
  ! BOOL            [ reduce using rule 25 (declare -> .) ]
  ! IF              [ reduce using rule 25 (declare -> .) ]
  ! DATA_TYPE       [ reduce using rule 25 (declare -> .) ]
  ! $end            [ reduce using rule 25 (declare -> .) ]
  ! R_CURLY         [ reduce using rule 25 (declare -> .) ]

    stmt                           shift and go to state 2
    S                              shift and go to state 27
    exp                            shift and go to state 3
    if                             shift and go to state 9
    dec_blk                        shift and go to state 13
    declare                        shift and go to state 14
    dec                            shift and go to state 25

state 3

    (3) stmt -> exp . SEMICOL
    (36) stmt -> exp . ASSIGNMENT exp SEMICOL
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         shift and go to state 28
    ASSIGNMENT      shift and go to state 29
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 4

    (4) stmt -> SEMICOL .

    SEMICOL         reduce using rule 4 (stmt -> SEMICOL .)
    L_ROUND         reduce using rule 4 (stmt -> SEMICOL .)
    L_CURLY         reduce using rule 4 (stmt -> SEMICOL .)
    L_SQR           reduce using rule 4 (stmt -> SEMICOL .)
    PRINT           reduce using rule 4 (stmt -> SEMICOL .)
    FOR             reduce using rule 4 (stmt -> SEMICOL .)
    STRUCT          reduce using rule 4 (stmt -> SEMICOL .)
    VAR_NAME        reduce using rule 4 (stmt -> SEMICOL .)
    FUNC_DEC        reduce using rule 4 (stmt -> SEMICOL .)
    RETURN          reduce using rule 4 (stmt -> SEMICOL .)
    MINUS           reduce using rule 4 (stmt -> SEMICOL .)
    NOT             reduce using rule 4 (stmt -> SEMICOL .)
    INT             reduce using rule 4 (stmt -> SEMICOL .)
    FLOAT           reduce using rule 4 (stmt -> SEMICOL .)
    STRING          reduce using rule 4 (stmt -> SEMICOL .)
    CHAR            reduce using rule 4 (stmt -> SEMICOL .)
    BOOL            reduce using rule 4 (stmt -> SEMICOL .)
    IF              reduce using rule 4 (stmt -> SEMICOL .)
    DATA_TYPE       reduce using rule 4 (stmt -> SEMICOL .)
    $end            reduce using rule 4 (stmt -> SEMICOL .)
    R_CURLY         reduce using rule 4 (stmt -> SEMICOL .)
    R_ROUND         reduce using rule 4 (stmt -> SEMICOL .)


state 5

    (5) stmt -> L_ROUND . R_ROUND
    (37) exp -> L_ROUND . exp R_ROUND
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    R_ROUND         shift and go to state 45
    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 46

state 6

    (6) stmt -> L_CURLY . R_CURLY
    (38) exp -> L_CURLY . exp R_CURLY
    (23) dec_blk -> L_CURLY . declare R_CURLY
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL
    (24) declare -> . dec declare
    (25) declare -> .
    (26) dec -> . DATA_TYPE VAR_NAME SEMICOL
    (27) dec -> . DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL

  ! shift/reduce conflict for R_CURLY resolved as shift
    R_CURLY         shift and go to state 50
    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23
    DATA_TYPE       shift and go to state 26

  ! R_CURLY         [ reduce using rule 25 (declare -> .) ]

    exp                            shift and go to state 51
    declare                        shift and go to state 52
    dec                            shift and go to state 25

state 7

    (7) stmt -> L_SQR . R_SQR
    (39) exp -> L_SQR . exp R_SQR
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    R_SQR           shift and go to state 53
    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 54

state 8

    (9) stmt -> PRINT . L_ROUND args R_ROUND SEMICOL

    L_ROUND         shift and go to state 55


state 9

    (13) stmt -> if .

    SEMICOL         reduce using rule 13 (stmt -> if .)
    L_ROUND         reduce using rule 13 (stmt -> if .)
    L_CURLY         reduce using rule 13 (stmt -> if .)
    L_SQR           reduce using rule 13 (stmt -> if .)
    PRINT           reduce using rule 13 (stmt -> if .)
    FOR             reduce using rule 13 (stmt -> if .)
    STRUCT          reduce using rule 13 (stmt -> if .)
    VAR_NAME        reduce using rule 13 (stmt -> if .)
    FUNC_DEC        reduce using rule 13 (stmt -> if .)
    RETURN          reduce using rule 13 (stmt -> if .)
    MINUS           reduce using rule 13 (stmt -> if .)
    NOT             reduce using rule 13 (stmt -> if .)
    INT             reduce using rule 13 (stmt -> if .)
    FLOAT           reduce using rule 13 (stmt -> if .)
    STRING          reduce using rule 13 (stmt -> if .)
    CHAR            reduce using rule 13 (stmt -> if .)
    BOOL            reduce using rule 13 (stmt -> if .)
    IF              reduce using rule 13 (stmt -> if .)
    DATA_TYPE       reduce using rule 13 (stmt -> if .)
    $end            reduce using rule 13 (stmt -> if .)
    R_CURLY         reduce using rule 13 (stmt -> if .)
    R_ROUND         reduce using rule 13 (stmt -> if .)


state 10

    (18) stmt -> FOR . L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk

    L_ROUND         shift and go to state 56


state 11

    (19) stmt -> STRUCT . VAR_NAME dec_blk

    VAR_NAME        shift and go to state 57


state 12

    (20) stmt -> VAR_NAME . VAR_NAME SEMICOL
    (35) stmt -> VAR_NAME . ASSIGNMENT exp SEMICOL
    (54) exp -> VAR_NAME . L_ROUND args R_ROUND
    (57) exp -> VAR_NAME . PLUS_PLUS
    (58) exp -> VAR_NAME . MINUS_MINUS
    (59) exp -> VAR_NAME .

  ! shift/reduce conflict for ASSIGNMENT resolved as shift
    VAR_NAME        shift and go to state 58
    ASSIGNMENT      shift and go to state 59
    L_ROUND         shift and go to state 60
    PLUS_PLUS       shift and go to state 61
    MINUS_MINUS     shift and go to state 62
    SEMICOL         reduce using rule 59 (exp -> VAR_NAME .)
    PLUS            reduce using rule 59 (exp -> VAR_NAME .)
    MINUS           reduce using rule 59 (exp -> VAR_NAME .)
    ASTERISK        reduce using rule 59 (exp -> VAR_NAME .)
    FWSLASH         reduce using rule 59 (exp -> VAR_NAME .)
    TOPI            reduce using rule 59 (exp -> VAR_NAME .)
    MOD             reduce using rule 59 (exp -> VAR_NAME .)
    LESSER          reduce using rule 59 (exp -> VAR_NAME .)
    GREATER         reduce using rule 59 (exp -> VAR_NAME .)
    LESSER_EQUAL    reduce using rule 59 (exp -> VAR_NAME .)
    GREATER_EQUAL   reduce using rule 59 (exp -> VAR_NAME .)
    IS_EQUAL        reduce using rule 59 (exp -> VAR_NAME .)
    NOT_EQUAL       reduce using rule 59 (exp -> VAR_NAME .)
    LOGICAL         reduce using rule 59 (exp -> VAR_NAME .)
    DOT             reduce using rule 59 (exp -> VAR_NAME .)

  ! ASSIGNMENT      [ reduce using rule 59 (exp -> VAR_NAME .) ]


state 13

    (22) stmt -> dec_blk .

    SEMICOL         reduce using rule 22 (stmt -> dec_blk .)
    L_ROUND         reduce using rule 22 (stmt -> dec_blk .)
    L_CURLY         reduce using rule 22 (stmt -> dec_blk .)
    L_SQR           reduce using rule 22 (stmt -> dec_blk .)
    PRINT           reduce using rule 22 (stmt -> dec_blk .)
    FOR             reduce using rule 22 (stmt -> dec_blk .)
    STRUCT          reduce using rule 22 (stmt -> dec_blk .)
    VAR_NAME        reduce using rule 22 (stmt -> dec_blk .)
    FUNC_DEC        reduce using rule 22 (stmt -> dec_blk .)
    RETURN          reduce using rule 22 (stmt -> dec_blk .)
    MINUS           reduce using rule 22 (stmt -> dec_blk .)
    NOT             reduce using rule 22 (stmt -> dec_blk .)
    INT             reduce using rule 22 (stmt -> dec_blk .)
    FLOAT           reduce using rule 22 (stmt -> dec_blk .)
    STRING          reduce using rule 22 (stmt -> dec_blk .)
    CHAR            reduce using rule 22 (stmt -> dec_blk .)
    BOOL            reduce using rule 22 (stmt -> dec_blk .)
    IF              reduce using rule 22 (stmt -> dec_blk .)
    DATA_TYPE       reduce using rule 22 (stmt -> dec_blk .)
    $end            reduce using rule 22 (stmt -> dec_blk .)
    R_CURLY         reduce using rule 22 (stmt -> dec_blk .)
    R_ROUND         reduce using rule 22 (stmt -> dec_blk .)


state 14

    (21) stmt -> declare .

    SEMICOL         reduce using rule 21 (stmt -> declare .)
    L_ROUND         reduce using rule 21 (stmt -> declare .)
    L_CURLY         reduce using rule 21 (stmt -> declare .)
    L_SQR           reduce using rule 21 (stmt -> declare .)
    PRINT           reduce using rule 21 (stmt -> declare .)
    FOR             reduce using rule 21 (stmt -> declare .)
    STRUCT          reduce using rule 21 (stmt -> declare .)
    VAR_NAME        reduce using rule 21 (stmt -> declare .)
    FUNC_DEC        reduce using rule 21 (stmt -> declare .)
    RETURN          reduce using rule 21 (stmt -> declare .)
    MINUS           reduce using rule 21 (stmt -> declare .)
    NOT             reduce using rule 21 (stmt -> declare .)
    INT             reduce using rule 21 (stmt -> declare .)
    FLOAT           reduce using rule 21 (stmt -> declare .)
    STRING          reduce using rule 21 (stmt -> declare .)
    CHAR            reduce using rule 21 (stmt -> declare .)
    BOOL            reduce using rule 21 (stmt -> declare .)
    IF              reduce using rule 21 (stmt -> declare .)
    DATA_TYPE       reduce using rule 21 (stmt -> declare .)
    $end            reduce using rule 21 (stmt -> declare .)
    R_CURLY         reduce using rule 21 (stmt -> declare .)
    R_ROUND         reduce using rule 21 (stmt -> declare .)


state 15

    (28) stmt -> FUNC_DEC . VAR_NAME param_blk stmt_blk

    VAR_NAME        shift and go to state 63


state 16

    (33) stmt -> RETURN . exp SEMICOL
    (34) stmt -> RETURN . SEMICOL
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    SEMICOL         shift and go to state 65
    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 64

state 17

    (55) exp -> MINUS . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 66

state 18

    (56) exp -> NOT . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 67

state 19

    (60) exp -> INT .

    SEMICOL         reduce using rule 60 (exp -> INT .)
    ASSIGNMENT      reduce using rule 60 (exp -> INT .)
    PLUS            reduce using rule 60 (exp -> INT .)
    MINUS           reduce using rule 60 (exp -> INT .)
    ASTERISK        reduce using rule 60 (exp -> INT .)
    FWSLASH         reduce using rule 60 (exp -> INT .)
    TOPI            reduce using rule 60 (exp -> INT .)
    MOD             reduce using rule 60 (exp -> INT .)
    LESSER          reduce using rule 60 (exp -> INT .)
    GREATER         reduce using rule 60 (exp -> INT .)
    LESSER_EQUAL    reduce using rule 60 (exp -> INT .)
    GREATER_EQUAL   reduce using rule 60 (exp -> INT .)
    IS_EQUAL        reduce using rule 60 (exp -> INT .)
    NOT_EQUAL       reduce using rule 60 (exp -> INT .)
    LOGICAL         reduce using rule 60 (exp -> INT .)
    DOT             reduce using rule 60 (exp -> INT .)
    R_ROUND         reduce using rule 60 (exp -> INT .)
    R_CURLY         reduce using rule 60 (exp -> INT .)
    R_SQR           reduce using rule 60 (exp -> INT .)
    COMMA           reduce using rule 60 (exp -> INT .)


state 20

    (61) exp -> FLOAT .

    SEMICOL         reduce using rule 61 (exp -> FLOAT .)
    ASSIGNMENT      reduce using rule 61 (exp -> FLOAT .)
    PLUS            reduce using rule 61 (exp -> FLOAT .)
    MINUS           reduce using rule 61 (exp -> FLOAT .)
    ASTERISK        reduce using rule 61 (exp -> FLOAT .)
    FWSLASH         reduce using rule 61 (exp -> FLOAT .)
    TOPI            reduce using rule 61 (exp -> FLOAT .)
    MOD             reduce using rule 61 (exp -> FLOAT .)
    LESSER          reduce using rule 61 (exp -> FLOAT .)
    GREATER         reduce using rule 61 (exp -> FLOAT .)
    LESSER_EQUAL    reduce using rule 61 (exp -> FLOAT .)
    GREATER_EQUAL   reduce using rule 61 (exp -> FLOAT .)
    IS_EQUAL        reduce using rule 61 (exp -> FLOAT .)
    NOT_EQUAL       reduce using rule 61 (exp -> FLOAT .)
    LOGICAL         reduce using rule 61 (exp -> FLOAT .)
    DOT             reduce using rule 61 (exp -> FLOAT .)
    R_ROUND         reduce using rule 61 (exp -> FLOAT .)
    R_CURLY         reduce using rule 61 (exp -> FLOAT .)
    R_SQR           reduce using rule 61 (exp -> FLOAT .)
    COMMA           reduce using rule 61 (exp -> FLOAT .)


state 21

    (62) exp -> STRING .

    SEMICOL         reduce using rule 62 (exp -> STRING .)
    ASSIGNMENT      reduce using rule 62 (exp -> STRING .)
    PLUS            reduce using rule 62 (exp -> STRING .)
    MINUS           reduce using rule 62 (exp -> STRING .)
    ASTERISK        reduce using rule 62 (exp -> STRING .)
    FWSLASH         reduce using rule 62 (exp -> STRING .)
    TOPI            reduce using rule 62 (exp -> STRING .)
    MOD             reduce using rule 62 (exp -> STRING .)
    LESSER          reduce using rule 62 (exp -> STRING .)
    GREATER         reduce using rule 62 (exp -> STRING .)
    LESSER_EQUAL    reduce using rule 62 (exp -> STRING .)
    GREATER_EQUAL   reduce using rule 62 (exp -> STRING .)
    IS_EQUAL        reduce using rule 62 (exp -> STRING .)
    NOT_EQUAL       reduce using rule 62 (exp -> STRING .)
    LOGICAL         reduce using rule 62 (exp -> STRING .)
    DOT             reduce using rule 62 (exp -> STRING .)
    R_ROUND         reduce using rule 62 (exp -> STRING .)
    R_CURLY         reduce using rule 62 (exp -> STRING .)
    R_SQR           reduce using rule 62 (exp -> STRING .)
    COMMA           reduce using rule 62 (exp -> STRING .)


state 22

    (63) exp -> CHAR .

    SEMICOL         reduce using rule 63 (exp -> CHAR .)
    ASSIGNMENT      reduce using rule 63 (exp -> CHAR .)
    PLUS            reduce using rule 63 (exp -> CHAR .)
    MINUS           reduce using rule 63 (exp -> CHAR .)
    ASTERISK        reduce using rule 63 (exp -> CHAR .)
    FWSLASH         reduce using rule 63 (exp -> CHAR .)
    TOPI            reduce using rule 63 (exp -> CHAR .)
    MOD             reduce using rule 63 (exp -> CHAR .)
    LESSER          reduce using rule 63 (exp -> CHAR .)
    GREATER         reduce using rule 63 (exp -> CHAR .)
    LESSER_EQUAL    reduce using rule 63 (exp -> CHAR .)
    GREATER_EQUAL   reduce using rule 63 (exp -> CHAR .)
    IS_EQUAL        reduce using rule 63 (exp -> CHAR .)
    NOT_EQUAL       reduce using rule 63 (exp -> CHAR .)
    LOGICAL         reduce using rule 63 (exp -> CHAR .)
    DOT             reduce using rule 63 (exp -> CHAR .)
    R_ROUND         reduce using rule 63 (exp -> CHAR .)
    R_CURLY         reduce using rule 63 (exp -> CHAR .)
    R_SQR           reduce using rule 63 (exp -> CHAR .)
    COMMA           reduce using rule 63 (exp -> CHAR .)


state 23

    (64) exp -> BOOL .

    SEMICOL         reduce using rule 64 (exp -> BOOL .)
    ASSIGNMENT      reduce using rule 64 (exp -> BOOL .)
    PLUS            reduce using rule 64 (exp -> BOOL .)
    MINUS           reduce using rule 64 (exp -> BOOL .)
    ASTERISK        reduce using rule 64 (exp -> BOOL .)
    FWSLASH         reduce using rule 64 (exp -> BOOL .)
    TOPI            reduce using rule 64 (exp -> BOOL .)
    MOD             reduce using rule 64 (exp -> BOOL .)
    LESSER          reduce using rule 64 (exp -> BOOL .)
    GREATER         reduce using rule 64 (exp -> BOOL .)
    LESSER_EQUAL    reduce using rule 64 (exp -> BOOL .)
    GREATER_EQUAL   reduce using rule 64 (exp -> BOOL .)
    IS_EQUAL        reduce using rule 64 (exp -> BOOL .)
    NOT_EQUAL       reduce using rule 64 (exp -> BOOL .)
    LOGICAL         reduce using rule 64 (exp -> BOOL .)
    DOT             reduce using rule 64 (exp -> BOOL .)
    R_ROUND         reduce using rule 64 (exp -> BOOL .)
    R_CURLY         reduce using rule 64 (exp -> BOOL .)
    R_SQR           reduce using rule 64 (exp -> BOOL .)
    COMMA           reduce using rule 64 (exp -> BOOL .)


state 24

    (14) if -> IF . L_ROUND exp R_ROUND stmt_blk else

    L_ROUND         shift and go to state 68


state 25

    (24) declare -> dec . declare
    (24) declare -> . dec declare
    (25) declare -> .
    (26) dec -> . DATA_TYPE VAR_NAME SEMICOL
    (27) dec -> . DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL

  ! shift/reduce conflict for DATA_TYPE resolved as shift
    SEMICOL         reduce using rule 25 (declare -> .)
    L_ROUND         reduce using rule 25 (declare -> .)
    L_CURLY         reduce using rule 25 (declare -> .)
    L_SQR           reduce using rule 25 (declare -> .)
    PRINT           reduce using rule 25 (declare -> .)
    FOR             reduce using rule 25 (declare -> .)
    STRUCT          reduce using rule 25 (declare -> .)
    VAR_NAME        reduce using rule 25 (declare -> .)
    FUNC_DEC        reduce using rule 25 (declare -> .)
    RETURN          reduce using rule 25 (declare -> .)
    MINUS           reduce using rule 25 (declare -> .)
    NOT             reduce using rule 25 (declare -> .)
    INT             reduce using rule 25 (declare -> .)
    FLOAT           reduce using rule 25 (declare -> .)
    STRING          reduce using rule 25 (declare -> .)
    CHAR            reduce using rule 25 (declare -> .)
    BOOL            reduce using rule 25 (declare -> .)
    IF              reduce using rule 25 (declare -> .)
    $end            reduce using rule 25 (declare -> .)
    R_CURLY         reduce using rule 25 (declare -> .)
    R_ROUND         reduce using rule 25 (declare -> .)
    DATA_TYPE       shift and go to state 26

  ! DATA_TYPE       [ reduce using rule 25 (declare -> .) ]

    dec                            shift and go to state 25
    declare                        shift and go to state 69

state 26

    (26) dec -> DATA_TYPE . VAR_NAME SEMICOL
    (27) dec -> DATA_TYPE . VAR_NAME ASSIGNMENT exp SEMICOL

    VAR_NAME        shift and go to state 70


state 27

    (1) S -> stmt S .

    $end            reduce using rule 1 (S -> stmt S .)
    R_CURLY         reduce using rule 1 (S -> stmt S .)


state 28

    (3) stmt -> exp SEMICOL .

    SEMICOL         reduce using rule 3 (stmt -> exp SEMICOL .)
    L_ROUND         reduce using rule 3 (stmt -> exp SEMICOL .)
    L_CURLY         reduce using rule 3 (stmt -> exp SEMICOL .)
    L_SQR           reduce using rule 3 (stmt -> exp SEMICOL .)
    PRINT           reduce using rule 3 (stmt -> exp SEMICOL .)
    FOR             reduce using rule 3 (stmt -> exp SEMICOL .)
    STRUCT          reduce using rule 3 (stmt -> exp SEMICOL .)
    VAR_NAME        reduce using rule 3 (stmt -> exp SEMICOL .)
    FUNC_DEC        reduce using rule 3 (stmt -> exp SEMICOL .)
    RETURN          reduce using rule 3 (stmt -> exp SEMICOL .)
    MINUS           reduce using rule 3 (stmt -> exp SEMICOL .)
    NOT             reduce using rule 3 (stmt -> exp SEMICOL .)
    INT             reduce using rule 3 (stmt -> exp SEMICOL .)
    FLOAT           reduce using rule 3 (stmt -> exp SEMICOL .)
    STRING          reduce using rule 3 (stmt -> exp SEMICOL .)
    CHAR            reduce using rule 3 (stmt -> exp SEMICOL .)
    BOOL            reduce using rule 3 (stmt -> exp SEMICOL .)
    IF              reduce using rule 3 (stmt -> exp SEMICOL .)
    DATA_TYPE       reduce using rule 3 (stmt -> exp SEMICOL .)
    $end            reduce using rule 3 (stmt -> exp SEMICOL .)
    R_CURLY         reduce using rule 3 (stmt -> exp SEMICOL .)
    R_ROUND         reduce using rule 3 (stmt -> exp SEMICOL .)


state 29

    (36) stmt -> exp ASSIGNMENT . exp SEMICOL
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 71

state 30

    (40) exp -> exp PLUS . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 72

state 31

    (41) exp -> exp MINUS . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 73

state 32

    (42) exp -> exp ASTERISK . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 74

state 33

    (43) exp -> exp FWSLASH . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 75

state 34

    (44) exp -> exp TOPI . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 76

state 35

    (45) exp -> exp MOD . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 77

state 36

    (46) exp -> exp LESSER . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 78

state 37

    (47) exp -> exp GREATER . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 79

state 38

    (48) exp -> exp LESSER_EQUAL . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 80

state 39

    (49) exp -> exp GREATER_EQUAL . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 81

state 40

    (50) exp -> exp IS_EQUAL . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 82

state 41

    (51) exp -> exp NOT_EQUAL . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 83

state 42

    (52) exp -> exp LOGICAL . exp
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 84

state 43

    (53) exp -> exp DOT . VAR_NAME

    VAR_NAME        shift and go to state 85


state 44

    (37) exp -> L_ROUND . exp R_ROUND
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 46

state 45

    (5) stmt -> L_ROUND R_ROUND .

    SEMICOL         reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    L_ROUND         reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    L_CURLY         reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    L_SQR           reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    PRINT           reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    FOR             reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    STRUCT          reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    VAR_NAME        reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    FUNC_DEC        reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    RETURN          reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    MINUS           reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    NOT             reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    INT             reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    FLOAT           reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    STRING          reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    CHAR            reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    BOOL            reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    IF              reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    DATA_TYPE       reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    $end            reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    R_CURLY         reduce using rule 5 (stmt -> L_ROUND R_ROUND .)
    R_ROUND         reduce using rule 5 (stmt -> L_ROUND R_ROUND .)


state 46

    (37) exp -> L_ROUND exp . R_ROUND
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    R_ROUND         shift and go to state 86
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 47

    (38) exp -> L_CURLY . exp R_CURLY
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 51

state 48

    (39) exp -> L_SQR . exp R_SQR
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 54

state 49

    (54) exp -> VAR_NAME . L_ROUND args R_ROUND
    (57) exp -> VAR_NAME . PLUS_PLUS
    (58) exp -> VAR_NAME . MINUS_MINUS
    (59) exp -> VAR_NAME .

    L_ROUND         shift and go to state 60
    PLUS_PLUS       shift and go to state 61
    MINUS_MINUS     shift and go to state 62
    R_ROUND         reduce using rule 59 (exp -> VAR_NAME .)
    PLUS            reduce using rule 59 (exp -> VAR_NAME .)
    MINUS           reduce using rule 59 (exp -> VAR_NAME .)
    ASTERISK        reduce using rule 59 (exp -> VAR_NAME .)
    FWSLASH         reduce using rule 59 (exp -> VAR_NAME .)
    TOPI            reduce using rule 59 (exp -> VAR_NAME .)
    MOD             reduce using rule 59 (exp -> VAR_NAME .)
    LESSER          reduce using rule 59 (exp -> VAR_NAME .)
    GREATER         reduce using rule 59 (exp -> VAR_NAME .)
    LESSER_EQUAL    reduce using rule 59 (exp -> VAR_NAME .)
    GREATER_EQUAL   reduce using rule 59 (exp -> VAR_NAME .)
    IS_EQUAL        reduce using rule 59 (exp -> VAR_NAME .)
    NOT_EQUAL       reduce using rule 59 (exp -> VAR_NAME .)
    LOGICAL         reduce using rule 59 (exp -> VAR_NAME .)
    DOT             reduce using rule 59 (exp -> VAR_NAME .)
    R_CURLY         reduce using rule 59 (exp -> VAR_NAME .)
    R_SQR           reduce using rule 59 (exp -> VAR_NAME .)
    SEMICOL         reduce using rule 59 (exp -> VAR_NAME .)
    ASSIGNMENT      reduce using rule 59 (exp -> VAR_NAME .)
    COMMA           reduce using rule 59 (exp -> VAR_NAME .)


state 50

    (6) stmt -> L_CURLY R_CURLY .

    SEMICOL         reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    L_ROUND         reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    L_CURLY         reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    L_SQR           reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    PRINT           reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    FOR             reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    STRUCT          reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    VAR_NAME        reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    FUNC_DEC        reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    RETURN          reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    MINUS           reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    NOT             reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    INT             reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    FLOAT           reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    STRING          reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    CHAR            reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    BOOL            reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    IF              reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    DATA_TYPE       reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    $end            reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    R_CURLY         reduce using rule 6 (stmt -> L_CURLY R_CURLY .)
    R_ROUND         reduce using rule 6 (stmt -> L_CURLY R_CURLY .)


state 51

    (38) exp -> L_CURLY exp . R_CURLY
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    R_CURLY         shift and go to state 87
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 52

    (23) dec_blk -> L_CURLY declare . R_CURLY

    R_CURLY         shift and go to state 88


state 53

    (7) stmt -> L_SQR R_SQR .

    SEMICOL         reduce using rule 7 (stmt -> L_SQR R_SQR .)
    L_ROUND         reduce using rule 7 (stmt -> L_SQR R_SQR .)
    L_CURLY         reduce using rule 7 (stmt -> L_SQR R_SQR .)
    L_SQR           reduce using rule 7 (stmt -> L_SQR R_SQR .)
    PRINT           reduce using rule 7 (stmt -> L_SQR R_SQR .)
    FOR             reduce using rule 7 (stmt -> L_SQR R_SQR .)
    STRUCT          reduce using rule 7 (stmt -> L_SQR R_SQR .)
    VAR_NAME        reduce using rule 7 (stmt -> L_SQR R_SQR .)
    FUNC_DEC        reduce using rule 7 (stmt -> L_SQR R_SQR .)
    RETURN          reduce using rule 7 (stmt -> L_SQR R_SQR .)
    MINUS           reduce using rule 7 (stmt -> L_SQR R_SQR .)
    NOT             reduce using rule 7 (stmt -> L_SQR R_SQR .)
    INT             reduce using rule 7 (stmt -> L_SQR R_SQR .)
    FLOAT           reduce using rule 7 (stmt -> L_SQR R_SQR .)
    STRING          reduce using rule 7 (stmt -> L_SQR R_SQR .)
    CHAR            reduce using rule 7 (stmt -> L_SQR R_SQR .)
    BOOL            reduce using rule 7 (stmt -> L_SQR R_SQR .)
    IF              reduce using rule 7 (stmt -> L_SQR R_SQR .)
    DATA_TYPE       reduce using rule 7 (stmt -> L_SQR R_SQR .)
    $end            reduce using rule 7 (stmt -> L_SQR R_SQR .)
    R_CURLY         reduce using rule 7 (stmt -> L_SQR R_SQR .)
    R_ROUND         reduce using rule 7 (stmt -> L_SQR R_SQR .)


state 54

    (39) exp -> L_SQR exp . R_SQR
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    R_SQR           shift and go to state 89
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 55

    (9) stmt -> PRINT L_ROUND . args R_ROUND SEMICOL
    (10) args -> . args COMMA args
    (11) args -> . exp
    (12) args -> .
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    R_ROUND         reduce using rule 12 (args -> .)
    COMMA           reduce using rule 12 (args -> .)
    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    args                           shift and go to state 90
    exp                            shift and go to state 91

state 56

    (18) stmt -> FOR L_ROUND . stmt exp SEMICOL stmt R_ROUND stmt_blk
    (3) stmt -> . exp SEMICOL
    (4) stmt -> . SEMICOL
    (5) stmt -> . L_ROUND R_ROUND
    (6) stmt -> . L_CURLY R_CURLY
    (7) stmt -> . L_SQR R_SQR
    (9) stmt -> . PRINT L_ROUND args R_ROUND SEMICOL
    (13) stmt -> . if
    (18) stmt -> . FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk
    (19) stmt -> . STRUCT VAR_NAME dec_blk
    (20) stmt -> . VAR_NAME VAR_NAME SEMICOL
    (21) stmt -> . declare
    (22) stmt -> . dec_blk
    (28) stmt -> . FUNC_DEC VAR_NAME param_blk stmt_blk
    (33) stmt -> . RETURN exp SEMICOL
    (34) stmt -> . RETURN SEMICOL
    (35) stmt -> . VAR_NAME ASSIGNMENT exp SEMICOL
    (36) stmt -> . exp ASSIGNMENT exp SEMICOL
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL
    (14) if -> . IF L_ROUND exp R_ROUND stmt_blk else
    (24) declare -> . dec declare
    (25) declare -> .
    (23) dec_blk -> . L_CURLY declare R_CURLY
    (26) dec -> . DATA_TYPE VAR_NAME SEMICOL
    (27) dec -> . DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL

  ! shift/reduce conflict for L_ROUND resolved as shift
  ! shift/reduce conflict for L_CURLY resolved as shift
  ! shift/reduce conflict for L_SQR resolved as shift
  ! shift/reduce conflict for VAR_NAME resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
    SEMICOL         shift and go to state 4
    L_ROUND         shift and go to state 5
    L_CURLY         shift and go to state 6
    L_SQR           shift and go to state 7
    PRINT           shift and go to state 8
    FOR             shift and go to state 10
    STRUCT          shift and go to state 11
    VAR_NAME        shift and go to state 12
    FUNC_DEC        shift and go to state 15
    RETURN          shift and go to state 16
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23
    IF              shift and go to state 24
    DATA_TYPE       shift and go to state 26

  ! L_ROUND         [ reduce using rule 25 (declare -> .) ]
  ! L_CURLY         [ reduce using rule 25 (declare -> .) ]
  ! L_SQR           [ reduce using rule 25 (declare -> .) ]
  ! VAR_NAME        [ reduce using rule 25 (declare -> .) ]
  ! MINUS           [ reduce using rule 25 (declare -> .) ]
  ! NOT             [ reduce using rule 25 (declare -> .) ]
  ! INT             [ reduce using rule 25 (declare -> .) ]
  ! FLOAT           [ reduce using rule 25 (declare -> .) ]
  ! STRING          [ reduce using rule 25 (declare -> .) ]
  ! CHAR            [ reduce using rule 25 (declare -> .) ]
  ! BOOL            [ reduce using rule 25 (declare -> .) ]

    stmt                           shift and go to state 92
    exp                            shift and go to state 3
    if                             shift and go to state 9
    dec_blk                        shift and go to state 13
    declare                        shift and go to state 14
    dec                            shift and go to state 25

state 57

    (19) stmt -> STRUCT VAR_NAME . dec_blk
    (23) dec_blk -> . L_CURLY declare R_CURLY

    L_CURLY         shift and go to state 94

    dec_blk                        shift and go to state 93

state 58

    (20) stmt -> VAR_NAME VAR_NAME . SEMICOL

    SEMICOL         shift and go to state 95


state 59

    (35) stmt -> VAR_NAME ASSIGNMENT . exp SEMICOL
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 96

state 60

    (54) exp -> VAR_NAME L_ROUND . args R_ROUND
    (10) args -> . args COMMA args
    (11) args -> . exp
    (12) args -> .
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    R_ROUND         reduce using rule 12 (args -> .)
    COMMA           reduce using rule 12 (args -> .)
    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    args                           shift and go to state 97
    exp                            shift and go to state 91

state 61

    (57) exp -> VAR_NAME PLUS_PLUS .

    SEMICOL         reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    ASSIGNMENT      reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    PLUS            reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    MINUS           reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    ASTERISK        reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    FWSLASH         reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    TOPI            reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    MOD             reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    LESSER          reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    GREATER         reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    LESSER_EQUAL    reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    GREATER_EQUAL   reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    IS_EQUAL        reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    NOT_EQUAL       reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    LOGICAL         reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    DOT             reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    R_ROUND         reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    R_CURLY         reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    R_SQR           reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)
    COMMA           reduce using rule 57 (exp -> VAR_NAME PLUS_PLUS .)


state 62

    (58) exp -> VAR_NAME MINUS_MINUS .

    SEMICOL         reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    ASSIGNMENT      reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    PLUS            reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    MINUS           reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    ASTERISK        reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    FWSLASH         reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    TOPI            reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    MOD             reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    LESSER          reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    GREATER         reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    LESSER_EQUAL    reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    GREATER_EQUAL   reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    IS_EQUAL        reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    NOT_EQUAL       reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    LOGICAL         reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    DOT             reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    R_ROUND         reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    R_CURLY         reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    R_SQR           reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)
    COMMA           reduce using rule 58 (exp -> VAR_NAME MINUS_MINUS .)


state 63

    (28) stmt -> FUNC_DEC VAR_NAME . param_blk stmt_blk
    (29) param_blk -> . L_ROUND param R_ROUND

    L_ROUND         shift and go to state 99

    param_blk                      shift and go to state 98

state 64

    (33) stmt -> RETURN exp . SEMICOL
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         shift and go to state 100
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 65

    (34) stmt -> RETURN SEMICOL .

    SEMICOL         reduce using rule 34 (stmt -> RETURN SEMICOL .)
    L_ROUND         reduce using rule 34 (stmt -> RETURN SEMICOL .)
    L_CURLY         reduce using rule 34 (stmt -> RETURN SEMICOL .)
    L_SQR           reduce using rule 34 (stmt -> RETURN SEMICOL .)
    PRINT           reduce using rule 34 (stmt -> RETURN SEMICOL .)
    FOR             reduce using rule 34 (stmt -> RETURN SEMICOL .)
    STRUCT          reduce using rule 34 (stmt -> RETURN SEMICOL .)
    VAR_NAME        reduce using rule 34 (stmt -> RETURN SEMICOL .)
    FUNC_DEC        reduce using rule 34 (stmt -> RETURN SEMICOL .)
    RETURN          reduce using rule 34 (stmt -> RETURN SEMICOL .)
    MINUS           reduce using rule 34 (stmt -> RETURN SEMICOL .)
    NOT             reduce using rule 34 (stmt -> RETURN SEMICOL .)
    INT             reduce using rule 34 (stmt -> RETURN SEMICOL .)
    FLOAT           reduce using rule 34 (stmt -> RETURN SEMICOL .)
    STRING          reduce using rule 34 (stmt -> RETURN SEMICOL .)
    CHAR            reduce using rule 34 (stmt -> RETURN SEMICOL .)
    BOOL            reduce using rule 34 (stmt -> RETURN SEMICOL .)
    IF              reduce using rule 34 (stmt -> RETURN SEMICOL .)
    DATA_TYPE       reduce using rule 34 (stmt -> RETURN SEMICOL .)
    $end            reduce using rule 34 (stmt -> RETURN SEMICOL .)
    R_CURLY         reduce using rule 34 (stmt -> RETURN SEMICOL .)
    R_ROUND         reduce using rule 34 (stmt -> RETURN SEMICOL .)


state 66

    (55) exp -> MINUS exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 55 (exp -> MINUS exp .)
    ASSIGNMENT      reduce using rule 55 (exp -> MINUS exp .)
    PLUS            reduce using rule 55 (exp -> MINUS exp .)
    MINUS           reduce using rule 55 (exp -> MINUS exp .)
    LESSER          reduce using rule 55 (exp -> MINUS exp .)
    GREATER         reduce using rule 55 (exp -> MINUS exp .)
    LESSER_EQUAL    reduce using rule 55 (exp -> MINUS exp .)
    GREATER_EQUAL   reduce using rule 55 (exp -> MINUS exp .)
    IS_EQUAL        reduce using rule 55 (exp -> MINUS exp .)
    NOT_EQUAL       reduce using rule 55 (exp -> MINUS exp .)
    LOGICAL         reduce using rule 55 (exp -> MINUS exp .)
    DOT             reduce using rule 55 (exp -> MINUS exp .)
    R_ROUND         reduce using rule 55 (exp -> MINUS exp .)
    R_CURLY         reduce using rule 55 (exp -> MINUS exp .)
    R_SQR           reduce using rule 55 (exp -> MINUS exp .)
    COMMA           reduce using rule 55 (exp -> MINUS exp .)
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! ASTERISK        [ reduce using rule 55 (exp -> MINUS exp .) ]
  ! FWSLASH         [ reduce using rule 55 (exp -> MINUS exp .) ]
  ! TOPI            [ reduce using rule 55 (exp -> MINUS exp .) ]
  ! MOD             [ reduce using rule 55 (exp -> MINUS exp .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 67

    (56) exp -> NOT exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for FWSLASH resolved as shift
  ! shift/reduce conflict for TOPI resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for IS_EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LOGICAL resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    SEMICOL         reduce using rule 56 (exp -> NOT exp .)
    ASSIGNMENT      reduce using rule 56 (exp -> NOT exp .)
    R_ROUND         reduce using rule 56 (exp -> NOT exp .)
    R_CURLY         reduce using rule 56 (exp -> NOT exp .)
    R_SQR           reduce using rule 56 (exp -> NOT exp .)
    COMMA           reduce using rule 56 (exp -> NOT exp .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43

  ! PLUS            [ reduce using rule 56 (exp -> NOT exp .) ]
  ! MINUS           [ reduce using rule 56 (exp -> NOT exp .) ]
  ! ASTERISK        [ reduce using rule 56 (exp -> NOT exp .) ]
  ! FWSLASH         [ reduce using rule 56 (exp -> NOT exp .) ]
  ! TOPI            [ reduce using rule 56 (exp -> NOT exp .) ]
  ! MOD             [ reduce using rule 56 (exp -> NOT exp .) ]
  ! LESSER          [ reduce using rule 56 (exp -> NOT exp .) ]
  ! GREATER         [ reduce using rule 56 (exp -> NOT exp .) ]
  ! LESSER_EQUAL    [ reduce using rule 56 (exp -> NOT exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (exp -> NOT exp .) ]
  ! IS_EQUAL        [ reduce using rule 56 (exp -> NOT exp .) ]
  ! NOT_EQUAL       [ reduce using rule 56 (exp -> NOT exp .) ]
  ! LOGICAL         [ reduce using rule 56 (exp -> NOT exp .) ]
  ! DOT             [ reduce using rule 56 (exp -> NOT exp .) ]


state 68

    (14) if -> IF L_ROUND . exp R_ROUND stmt_blk else
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 101

state 69

    (24) declare -> dec declare .

    SEMICOL         reduce using rule 24 (declare -> dec declare .)
    L_ROUND         reduce using rule 24 (declare -> dec declare .)
    L_CURLY         reduce using rule 24 (declare -> dec declare .)
    L_SQR           reduce using rule 24 (declare -> dec declare .)
    PRINT           reduce using rule 24 (declare -> dec declare .)
    FOR             reduce using rule 24 (declare -> dec declare .)
    STRUCT          reduce using rule 24 (declare -> dec declare .)
    VAR_NAME        reduce using rule 24 (declare -> dec declare .)
    FUNC_DEC        reduce using rule 24 (declare -> dec declare .)
    RETURN          reduce using rule 24 (declare -> dec declare .)
    MINUS           reduce using rule 24 (declare -> dec declare .)
    NOT             reduce using rule 24 (declare -> dec declare .)
    INT             reduce using rule 24 (declare -> dec declare .)
    FLOAT           reduce using rule 24 (declare -> dec declare .)
    STRING          reduce using rule 24 (declare -> dec declare .)
    CHAR            reduce using rule 24 (declare -> dec declare .)
    BOOL            reduce using rule 24 (declare -> dec declare .)
    IF              reduce using rule 24 (declare -> dec declare .)
    DATA_TYPE       reduce using rule 24 (declare -> dec declare .)
    $end            reduce using rule 24 (declare -> dec declare .)
    R_CURLY         reduce using rule 24 (declare -> dec declare .)
    R_ROUND         reduce using rule 24 (declare -> dec declare .)


state 70

    (26) dec -> DATA_TYPE VAR_NAME . SEMICOL
    (27) dec -> DATA_TYPE VAR_NAME . ASSIGNMENT exp SEMICOL

    SEMICOL         shift and go to state 102
    ASSIGNMENT      shift and go to state 103


state 71

    (36) stmt -> exp ASSIGNMENT exp . SEMICOL
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         shift and go to state 104
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 72

    (40) exp -> exp PLUS exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 40 (exp -> exp PLUS exp .)
    ASSIGNMENT      reduce using rule 40 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 40 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 40 (exp -> exp PLUS exp .)
    LESSER          reduce using rule 40 (exp -> exp PLUS exp .)
    GREATER         reduce using rule 40 (exp -> exp PLUS exp .)
    LESSER_EQUAL    reduce using rule 40 (exp -> exp PLUS exp .)
    GREATER_EQUAL   reduce using rule 40 (exp -> exp PLUS exp .)
    IS_EQUAL        reduce using rule 40 (exp -> exp PLUS exp .)
    NOT_EQUAL       reduce using rule 40 (exp -> exp PLUS exp .)
    LOGICAL         reduce using rule 40 (exp -> exp PLUS exp .)
    DOT             reduce using rule 40 (exp -> exp PLUS exp .)
    R_ROUND         reduce using rule 40 (exp -> exp PLUS exp .)
    R_CURLY         reduce using rule 40 (exp -> exp PLUS exp .)
    R_SQR           reduce using rule 40 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 40 (exp -> exp PLUS exp .)
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! ASTERISK        [ reduce using rule 40 (exp -> exp PLUS exp .) ]
  ! FWSLASH         [ reduce using rule 40 (exp -> exp PLUS exp .) ]
  ! TOPI            [ reduce using rule 40 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 40 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 73

    (41) exp -> exp MINUS exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 41 (exp -> exp MINUS exp .)
    ASSIGNMENT      reduce using rule 41 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 41 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 41 (exp -> exp MINUS exp .)
    LESSER          reduce using rule 41 (exp -> exp MINUS exp .)
    GREATER         reduce using rule 41 (exp -> exp MINUS exp .)
    LESSER_EQUAL    reduce using rule 41 (exp -> exp MINUS exp .)
    GREATER_EQUAL   reduce using rule 41 (exp -> exp MINUS exp .)
    IS_EQUAL        reduce using rule 41 (exp -> exp MINUS exp .)
    NOT_EQUAL       reduce using rule 41 (exp -> exp MINUS exp .)
    LOGICAL         reduce using rule 41 (exp -> exp MINUS exp .)
    DOT             reduce using rule 41 (exp -> exp MINUS exp .)
    R_ROUND         reduce using rule 41 (exp -> exp MINUS exp .)
    R_CURLY         reduce using rule 41 (exp -> exp MINUS exp .)
    R_SQR           reduce using rule 41 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 41 (exp -> exp MINUS exp .)
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! ASTERISK        [ reduce using rule 41 (exp -> exp MINUS exp .) ]
  ! FWSLASH         [ reduce using rule 41 (exp -> exp MINUS exp .) ]
  ! TOPI            [ reduce using rule 41 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 41 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 74

    (42) exp -> exp ASTERISK exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 42 (exp -> exp ASTERISK exp .)
    ASSIGNMENT      reduce using rule 42 (exp -> exp ASTERISK exp .)
    PLUS            reduce using rule 42 (exp -> exp ASTERISK exp .)
    MINUS           reduce using rule 42 (exp -> exp ASTERISK exp .)
    ASTERISK        reduce using rule 42 (exp -> exp ASTERISK exp .)
    FWSLASH         reduce using rule 42 (exp -> exp ASTERISK exp .)
    LESSER          reduce using rule 42 (exp -> exp ASTERISK exp .)
    GREATER         reduce using rule 42 (exp -> exp ASTERISK exp .)
    LESSER_EQUAL    reduce using rule 42 (exp -> exp ASTERISK exp .)
    GREATER_EQUAL   reduce using rule 42 (exp -> exp ASTERISK exp .)
    IS_EQUAL        reduce using rule 42 (exp -> exp ASTERISK exp .)
    NOT_EQUAL       reduce using rule 42 (exp -> exp ASTERISK exp .)
    LOGICAL         reduce using rule 42 (exp -> exp ASTERISK exp .)
    DOT             reduce using rule 42 (exp -> exp ASTERISK exp .)
    R_ROUND         reduce using rule 42 (exp -> exp ASTERISK exp .)
    R_CURLY         reduce using rule 42 (exp -> exp ASTERISK exp .)
    R_SQR           reduce using rule 42 (exp -> exp ASTERISK exp .)
    COMMA           reduce using rule 42 (exp -> exp ASTERISK exp .)
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! TOPI            [ reduce using rule 42 (exp -> exp ASTERISK exp .) ]
  ! MOD             [ reduce using rule 42 (exp -> exp ASTERISK exp .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! ASTERISK        [ shift and go to state 32 ]
  ! FWSLASH         [ shift and go to state 33 ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 75

    (43) exp -> exp FWSLASH exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 43 (exp -> exp FWSLASH exp .)
    ASSIGNMENT      reduce using rule 43 (exp -> exp FWSLASH exp .)
    PLUS            reduce using rule 43 (exp -> exp FWSLASH exp .)
    MINUS           reduce using rule 43 (exp -> exp FWSLASH exp .)
    ASTERISK        reduce using rule 43 (exp -> exp FWSLASH exp .)
    FWSLASH         reduce using rule 43 (exp -> exp FWSLASH exp .)
    LESSER          reduce using rule 43 (exp -> exp FWSLASH exp .)
    GREATER         reduce using rule 43 (exp -> exp FWSLASH exp .)
    LESSER_EQUAL    reduce using rule 43 (exp -> exp FWSLASH exp .)
    GREATER_EQUAL   reduce using rule 43 (exp -> exp FWSLASH exp .)
    IS_EQUAL        reduce using rule 43 (exp -> exp FWSLASH exp .)
    NOT_EQUAL       reduce using rule 43 (exp -> exp FWSLASH exp .)
    LOGICAL         reduce using rule 43 (exp -> exp FWSLASH exp .)
    DOT             reduce using rule 43 (exp -> exp FWSLASH exp .)
    R_ROUND         reduce using rule 43 (exp -> exp FWSLASH exp .)
    R_CURLY         reduce using rule 43 (exp -> exp FWSLASH exp .)
    R_SQR           reduce using rule 43 (exp -> exp FWSLASH exp .)
    COMMA           reduce using rule 43 (exp -> exp FWSLASH exp .)
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! TOPI            [ reduce using rule 43 (exp -> exp FWSLASH exp .) ]
  ! MOD             [ reduce using rule 43 (exp -> exp FWSLASH exp .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! ASTERISK        [ shift and go to state 32 ]
  ! FWSLASH         [ shift and go to state 33 ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 76

    (44) exp -> exp TOPI exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 44 (exp -> exp TOPI exp .)
    ASSIGNMENT      reduce using rule 44 (exp -> exp TOPI exp .)
    PLUS            reduce using rule 44 (exp -> exp TOPI exp .)
    MINUS           reduce using rule 44 (exp -> exp TOPI exp .)
    ASTERISK        reduce using rule 44 (exp -> exp TOPI exp .)
    FWSLASH         reduce using rule 44 (exp -> exp TOPI exp .)
    TOPI            reduce using rule 44 (exp -> exp TOPI exp .)
    MOD             reduce using rule 44 (exp -> exp TOPI exp .)
    LESSER          reduce using rule 44 (exp -> exp TOPI exp .)
    GREATER         reduce using rule 44 (exp -> exp TOPI exp .)
    LESSER_EQUAL    reduce using rule 44 (exp -> exp TOPI exp .)
    GREATER_EQUAL   reduce using rule 44 (exp -> exp TOPI exp .)
    IS_EQUAL        reduce using rule 44 (exp -> exp TOPI exp .)
    NOT_EQUAL       reduce using rule 44 (exp -> exp TOPI exp .)
    LOGICAL         reduce using rule 44 (exp -> exp TOPI exp .)
    DOT             reduce using rule 44 (exp -> exp TOPI exp .)
    R_ROUND         reduce using rule 44 (exp -> exp TOPI exp .)
    R_CURLY         reduce using rule 44 (exp -> exp TOPI exp .)
    R_SQR           reduce using rule 44 (exp -> exp TOPI exp .)
    COMMA           reduce using rule 44 (exp -> exp TOPI exp .)

  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! ASTERISK        [ shift and go to state 32 ]
  ! FWSLASH         [ shift and go to state 33 ]
  ! TOPI            [ shift and go to state 34 ]
  ! MOD             [ shift and go to state 35 ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 77

    (45) exp -> exp MOD exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 45 (exp -> exp MOD exp .)
    ASSIGNMENT      reduce using rule 45 (exp -> exp MOD exp .)
    PLUS            reduce using rule 45 (exp -> exp MOD exp .)
    MINUS           reduce using rule 45 (exp -> exp MOD exp .)
    ASTERISK        reduce using rule 45 (exp -> exp MOD exp .)
    FWSLASH         reduce using rule 45 (exp -> exp MOD exp .)
    TOPI            reduce using rule 45 (exp -> exp MOD exp .)
    MOD             reduce using rule 45 (exp -> exp MOD exp .)
    LESSER          reduce using rule 45 (exp -> exp MOD exp .)
    GREATER         reduce using rule 45 (exp -> exp MOD exp .)
    LESSER_EQUAL    reduce using rule 45 (exp -> exp MOD exp .)
    GREATER_EQUAL   reduce using rule 45 (exp -> exp MOD exp .)
    IS_EQUAL        reduce using rule 45 (exp -> exp MOD exp .)
    NOT_EQUAL       reduce using rule 45 (exp -> exp MOD exp .)
    LOGICAL         reduce using rule 45 (exp -> exp MOD exp .)
    DOT             reduce using rule 45 (exp -> exp MOD exp .)
    R_ROUND         reduce using rule 45 (exp -> exp MOD exp .)
    R_CURLY         reduce using rule 45 (exp -> exp MOD exp .)
    R_SQR           reduce using rule 45 (exp -> exp MOD exp .)
    COMMA           reduce using rule 45 (exp -> exp MOD exp .)

  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! ASTERISK        [ shift and go to state 32 ]
  ! FWSLASH         [ shift and go to state 33 ]
  ! TOPI            [ shift and go to state 34 ]
  ! MOD             [ shift and go to state 35 ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 78

    (46) exp -> exp LESSER exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 46 (exp -> exp LESSER exp .)
    ASSIGNMENT      reduce using rule 46 (exp -> exp LESSER exp .)
    LESSER          reduce using rule 46 (exp -> exp LESSER exp .)
    GREATER         reduce using rule 46 (exp -> exp LESSER exp .)
    LESSER_EQUAL    reduce using rule 46 (exp -> exp LESSER exp .)
    GREATER_EQUAL   reduce using rule 46 (exp -> exp LESSER exp .)
    IS_EQUAL        reduce using rule 46 (exp -> exp LESSER exp .)
    NOT_EQUAL       reduce using rule 46 (exp -> exp LESSER exp .)
    LOGICAL         reduce using rule 46 (exp -> exp LESSER exp .)
    DOT             reduce using rule 46 (exp -> exp LESSER exp .)
    R_ROUND         reduce using rule 46 (exp -> exp LESSER exp .)
    R_CURLY         reduce using rule 46 (exp -> exp LESSER exp .)
    R_SQR           reduce using rule 46 (exp -> exp LESSER exp .)
    COMMA           reduce using rule 46 (exp -> exp LESSER exp .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! PLUS            [ reduce using rule 46 (exp -> exp LESSER exp .) ]
  ! MINUS           [ reduce using rule 46 (exp -> exp LESSER exp .) ]
  ! ASTERISK        [ reduce using rule 46 (exp -> exp LESSER exp .) ]
  ! FWSLASH         [ reduce using rule 46 (exp -> exp LESSER exp .) ]
  ! TOPI            [ reduce using rule 46 (exp -> exp LESSER exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> exp LESSER exp .) ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 79

    (47) exp -> exp GREATER exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 47 (exp -> exp GREATER exp .)
    ASSIGNMENT      reduce using rule 47 (exp -> exp GREATER exp .)
    LESSER          reduce using rule 47 (exp -> exp GREATER exp .)
    GREATER         reduce using rule 47 (exp -> exp GREATER exp .)
    LESSER_EQUAL    reduce using rule 47 (exp -> exp GREATER exp .)
    GREATER_EQUAL   reduce using rule 47 (exp -> exp GREATER exp .)
    IS_EQUAL        reduce using rule 47 (exp -> exp GREATER exp .)
    NOT_EQUAL       reduce using rule 47 (exp -> exp GREATER exp .)
    LOGICAL         reduce using rule 47 (exp -> exp GREATER exp .)
    DOT             reduce using rule 47 (exp -> exp GREATER exp .)
    R_ROUND         reduce using rule 47 (exp -> exp GREATER exp .)
    R_CURLY         reduce using rule 47 (exp -> exp GREATER exp .)
    R_SQR           reduce using rule 47 (exp -> exp GREATER exp .)
    COMMA           reduce using rule 47 (exp -> exp GREATER exp .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! PLUS            [ reduce using rule 47 (exp -> exp GREATER exp .) ]
  ! MINUS           [ reduce using rule 47 (exp -> exp GREATER exp .) ]
  ! ASTERISK        [ reduce using rule 47 (exp -> exp GREATER exp .) ]
  ! FWSLASH         [ reduce using rule 47 (exp -> exp GREATER exp .) ]
  ! TOPI            [ reduce using rule 47 (exp -> exp GREATER exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> exp GREATER exp .) ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 80

    (48) exp -> exp LESSER_EQUAL exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    ASSIGNMENT      reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    LESSER          reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    GREATER         reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    LESSER_EQUAL    reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    IS_EQUAL        reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    NOT_EQUAL       reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    LOGICAL         reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    DOT             reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    R_ROUND         reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    R_CURLY         reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    R_SQR           reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    COMMA           reduce using rule 48 (exp -> exp LESSER_EQUAL exp .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! PLUS            [ reduce using rule 48 (exp -> exp LESSER_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 48 (exp -> exp LESSER_EQUAL exp .) ]
  ! ASTERISK        [ reduce using rule 48 (exp -> exp LESSER_EQUAL exp .) ]
  ! FWSLASH         [ reduce using rule 48 (exp -> exp LESSER_EQUAL exp .) ]
  ! TOPI            [ reduce using rule 48 (exp -> exp LESSER_EQUAL exp .) ]
  ! MOD             [ reduce using rule 48 (exp -> exp LESSER_EQUAL exp .) ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 81

    (49) exp -> exp GREATER_EQUAL exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    ASSIGNMENT      reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    LESSER          reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    GREATER         reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    LESSER_EQUAL    reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    IS_EQUAL        reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    NOT_EQUAL       reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    LOGICAL         reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    DOT             reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    R_ROUND         reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    R_CURLY         reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    R_SQR           reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    COMMA           reduce using rule 49 (exp -> exp GREATER_EQUAL exp .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! PLUS            [ reduce using rule 49 (exp -> exp GREATER_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 49 (exp -> exp GREATER_EQUAL exp .) ]
  ! ASTERISK        [ reduce using rule 49 (exp -> exp GREATER_EQUAL exp .) ]
  ! FWSLASH         [ reduce using rule 49 (exp -> exp GREATER_EQUAL exp .) ]
  ! TOPI            [ reduce using rule 49 (exp -> exp GREATER_EQUAL exp .) ]
  ! MOD             [ reduce using rule 49 (exp -> exp GREATER_EQUAL exp .) ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 82

    (50) exp -> exp IS_EQUAL exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    ASSIGNMENT      reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    LESSER          reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    GREATER         reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    LESSER_EQUAL    reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    IS_EQUAL        reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    NOT_EQUAL       reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    LOGICAL         reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    DOT             reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    R_ROUND         reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    R_CURLY         reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    R_SQR           reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    COMMA           reduce using rule 50 (exp -> exp IS_EQUAL exp .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! PLUS            [ reduce using rule 50 (exp -> exp IS_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 50 (exp -> exp IS_EQUAL exp .) ]
  ! ASTERISK        [ reduce using rule 50 (exp -> exp IS_EQUAL exp .) ]
  ! FWSLASH         [ reduce using rule 50 (exp -> exp IS_EQUAL exp .) ]
  ! TOPI            [ reduce using rule 50 (exp -> exp IS_EQUAL exp .) ]
  ! MOD             [ reduce using rule 50 (exp -> exp IS_EQUAL exp .) ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 83

    (51) exp -> exp NOT_EQUAL exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    ASSIGNMENT      reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    LESSER          reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    GREATER         reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    LESSER_EQUAL    reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    IS_EQUAL        reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    NOT_EQUAL       reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    LOGICAL         reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    DOT             reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    R_ROUND         reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    R_CURLY         reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    R_SQR           reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    COMMA           reduce using rule 51 (exp -> exp NOT_EQUAL exp .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35

  ! PLUS            [ reduce using rule 51 (exp -> exp NOT_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 51 (exp -> exp NOT_EQUAL exp .) ]
  ! ASTERISK        [ reduce using rule 51 (exp -> exp NOT_EQUAL exp .) ]
  ! FWSLASH         [ reduce using rule 51 (exp -> exp NOT_EQUAL exp .) ]
  ! TOPI            [ reduce using rule 51 (exp -> exp NOT_EQUAL exp .) ]
  ! MOD             [ reduce using rule 51 (exp -> exp NOT_EQUAL exp .) ]
  ! LESSER          [ shift and go to state 36 ]
  ! GREATER         [ shift and go to state 37 ]
  ! LESSER_EQUAL    [ shift and go to state 38 ]
  ! GREATER_EQUAL   [ shift and go to state 39 ]
  ! IS_EQUAL        [ shift and go to state 40 ]
  ! NOT_EQUAL       [ shift and go to state 41 ]
  ! LOGICAL         [ shift and go to state 42 ]
  ! DOT             [ shift and go to state 43 ]


state 84

    (52) exp -> exp LOGICAL exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for FWSLASH resolved as shift
  ! shift/reduce conflict for TOPI resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for IS_EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LOGICAL resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    SEMICOL         reduce using rule 52 (exp -> exp LOGICAL exp .)
    ASSIGNMENT      reduce using rule 52 (exp -> exp LOGICAL exp .)
    R_ROUND         reduce using rule 52 (exp -> exp LOGICAL exp .)
    R_CURLY         reduce using rule 52 (exp -> exp LOGICAL exp .)
    R_SQR           reduce using rule 52 (exp -> exp LOGICAL exp .)
    COMMA           reduce using rule 52 (exp -> exp LOGICAL exp .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43

  ! PLUS            [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! MINUS           [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! ASTERISK        [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! FWSLASH         [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! TOPI            [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! MOD             [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! LESSER          [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! GREATER         [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! LESSER_EQUAL    [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! IS_EQUAL        [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! NOT_EQUAL       [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! LOGICAL         [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]
  ! DOT             [ reduce using rule 52 (exp -> exp LOGICAL exp .) ]


state 85

    (53) exp -> exp DOT VAR_NAME .

    SEMICOL         reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    ASSIGNMENT      reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    PLUS            reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    MINUS           reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    ASTERISK        reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    FWSLASH         reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    TOPI            reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    MOD             reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    LESSER          reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    GREATER         reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    LESSER_EQUAL    reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    GREATER_EQUAL   reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    IS_EQUAL        reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    NOT_EQUAL       reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    LOGICAL         reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    DOT             reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    R_ROUND         reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    R_CURLY         reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    R_SQR           reduce using rule 53 (exp -> exp DOT VAR_NAME .)
    COMMA           reduce using rule 53 (exp -> exp DOT VAR_NAME .)


state 86

    (37) exp -> L_ROUND exp R_ROUND .

    SEMICOL         reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    ASSIGNMENT      reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    PLUS            reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    MINUS           reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    ASTERISK        reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    FWSLASH         reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    TOPI            reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    MOD             reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    LESSER          reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    GREATER         reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    LESSER_EQUAL    reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    GREATER_EQUAL   reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    IS_EQUAL        reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    NOT_EQUAL       reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    LOGICAL         reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    DOT             reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    R_ROUND         reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    R_CURLY         reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    R_SQR           reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)
    COMMA           reduce using rule 37 (exp -> L_ROUND exp R_ROUND .)


state 87

    (38) exp -> L_CURLY exp R_CURLY .

    SEMICOL         reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    ASSIGNMENT      reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    PLUS            reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    MINUS           reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    ASTERISK        reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    FWSLASH         reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    TOPI            reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    MOD             reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    LESSER          reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    GREATER         reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    LESSER_EQUAL    reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    GREATER_EQUAL   reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    IS_EQUAL        reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    NOT_EQUAL       reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    LOGICAL         reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    DOT             reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    R_ROUND         reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    R_CURLY         reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    R_SQR           reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)
    COMMA           reduce using rule 38 (exp -> L_CURLY exp R_CURLY .)


state 88

    (23) dec_blk -> L_CURLY declare R_CURLY .

    SEMICOL         reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    L_ROUND         reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    L_CURLY         reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    L_SQR           reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    PRINT           reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    FOR             reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    STRUCT          reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    VAR_NAME        reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    FUNC_DEC        reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    RETURN          reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    MINUS           reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    NOT             reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    INT             reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    FLOAT           reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    STRING          reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    CHAR            reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    BOOL            reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    IF              reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    DATA_TYPE       reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    $end            reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    R_CURLY         reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)
    R_ROUND         reduce using rule 23 (dec_blk -> L_CURLY declare R_CURLY .)


state 89

    (39) exp -> L_SQR exp R_SQR .

    SEMICOL         reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    ASSIGNMENT      reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    PLUS            reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    MINUS           reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    ASTERISK        reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    FWSLASH         reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    TOPI            reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    MOD             reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    LESSER          reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    GREATER         reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    LESSER_EQUAL    reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    GREATER_EQUAL   reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    IS_EQUAL        reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    NOT_EQUAL       reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    LOGICAL         reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    DOT             reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    R_ROUND         reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    R_CURLY         reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    R_SQR           reduce using rule 39 (exp -> L_SQR exp R_SQR .)
    COMMA           reduce using rule 39 (exp -> L_SQR exp R_SQR .)


state 90

    (9) stmt -> PRINT L_ROUND args . R_ROUND SEMICOL
    (10) args -> args . COMMA args

    R_ROUND         shift and go to state 105
    COMMA           shift and go to state 106


state 91

    (11) args -> exp .
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    R_ROUND         reduce using rule 11 (args -> exp .)
    COMMA           reduce using rule 11 (args -> exp .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 92

    (18) stmt -> FOR L_ROUND stmt . exp SEMICOL stmt R_ROUND stmt_blk
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 107

state 93

    (19) stmt -> STRUCT VAR_NAME dec_blk .

    SEMICOL         reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    L_ROUND         reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    L_CURLY         reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    L_SQR           reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    PRINT           reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    FOR             reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    STRUCT          reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    VAR_NAME        reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    FUNC_DEC        reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    RETURN          reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    MINUS           reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    NOT             reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    INT             reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    FLOAT           reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    STRING          reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    CHAR            reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    BOOL            reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    IF              reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    DATA_TYPE       reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    $end            reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    R_CURLY         reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)
    R_ROUND         reduce using rule 19 (stmt -> STRUCT VAR_NAME dec_blk .)


state 94

    (23) dec_blk -> L_CURLY . declare R_CURLY
    (24) declare -> . dec declare
    (25) declare -> .
    (26) dec -> . DATA_TYPE VAR_NAME SEMICOL
    (27) dec -> . DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL

    R_CURLY         reduce using rule 25 (declare -> .)
    DATA_TYPE       shift and go to state 26

    declare                        shift and go to state 52
    dec                            shift and go to state 25

state 95

    (20) stmt -> VAR_NAME VAR_NAME SEMICOL .

    SEMICOL         reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    L_ROUND         reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    L_CURLY         reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    L_SQR           reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    PRINT           reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    FOR             reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    STRUCT          reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    VAR_NAME        reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    FUNC_DEC        reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    RETURN          reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    MINUS           reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    NOT             reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    INT             reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    FLOAT           reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    STRING          reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    CHAR            reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    BOOL            reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    IF              reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    DATA_TYPE       reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    $end            reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    R_CURLY         reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)
    R_ROUND         reduce using rule 20 (stmt -> VAR_NAME VAR_NAME SEMICOL .)


state 96

    (35) stmt -> VAR_NAME ASSIGNMENT exp . SEMICOL
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         shift and go to state 108
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 97

    (54) exp -> VAR_NAME L_ROUND args . R_ROUND
    (10) args -> args . COMMA args

    R_ROUND         shift and go to state 109
    COMMA           shift and go to state 106


state 98

    (28) stmt -> FUNC_DEC VAR_NAME param_blk . stmt_blk
    (8) stmt_blk -> . L_CURLY S R_CURLY

    L_CURLY         shift and go to state 111

    stmt_blk                       shift and go to state 110

state 99

    (29) param_blk -> L_ROUND . param R_ROUND
    (30) param -> . param COMMA param
    (31) param -> . DATA_TYPE VAR_NAME
    (32) param -> .

    DATA_TYPE       shift and go to state 113
    R_ROUND         reduce using rule 32 (param -> .)
    COMMA           reduce using rule 32 (param -> .)

    param                          shift and go to state 112

state 100

    (33) stmt -> RETURN exp SEMICOL .

    SEMICOL         reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    L_ROUND         reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    L_CURLY         reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    L_SQR           reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    PRINT           reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    FOR             reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    STRUCT          reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    VAR_NAME        reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    FUNC_DEC        reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    RETURN          reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    MINUS           reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    NOT             reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    INT             reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    FLOAT           reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    STRING          reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    CHAR            reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    BOOL            reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    IF              reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    DATA_TYPE       reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    $end            reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    R_CURLY         reduce using rule 33 (stmt -> RETURN exp SEMICOL .)
    R_ROUND         reduce using rule 33 (stmt -> RETURN exp SEMICOL .)


state 101

    (14) if -> IF L_ROUND exp . R_ROUND stmt_blk else
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    R_ROUND         shift and go to state 114
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 102

    (26) dec -> DATA_TYPE VAR_NAME SEMICOL .

    DATA_TYPE       reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    SEMICOL         reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    L_ROUND         reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    L_CURLY         reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    L_SQR           reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    PRINT           reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    FOR             reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    STRUCT          reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    VAR_NAME        reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    FUNC_DEC        reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    RETURN          reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    MINUS           reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    NOT             reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    INT             reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    FLOAT           reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    STRING          reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    CHAR            reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    BOOL            reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    IF              reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    $end            reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    R_CURLY         reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)
    R_ROUND         reduce using rule 26 (dec -> DATA_TYPE VAR_NAME SEMICOL .)


state 103

    (27) dec -> DATA_TYPE VAR_NAME ASSIGNMENT . exp SEMICOL
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    exp                            shift and go to state 115

state 104

    (36) stmt -> exp ASSIGNMENT exp SEMICOL .

    SEMICOL         reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    L_ROUND         reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    L_CURLY         reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    L_SQR           reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    PRINT           reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    FOR             reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    STRUCT          reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    VAR_NAME        reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    FUNC_DEC        reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    RETURN          reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    MINUS           reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    NOT             reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    INT             reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    FLOAT           reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    STRING          reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    CHAR            reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    BOOL            reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    IF              reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    DATA_TYPE       reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    $end            reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    R_CURLY         reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)
    R_ROUND         reduce using rule 36 (stmt -> exp ASSIGNMENT exp SEMICOL .)


state 105

    (9) stmt -> PRINT L_ROUND args R_ROUND . SEMICOL

    SEMICOL         shift and go to state 116


state 106

    (10) args -> args COMMA . args
    (10) args -> . args COMMA args
    (11) args -> . exp
    (12) args -> .
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL

    COMMA           reduce using rule 12 (args -> .)
    R_ROUND         reduce using rule 12 (args -> .)
    L_ROUND         shift and go to state 44
    L_CURLY         shift and go to state 47
    L_SQR           shift and go to state 48
    VAR_NAME        shift and go to state 49
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23

    args                           shift and go to state 117
    exp                            shift and go to state 91

state 107

    (18) stmt -> FOR L_ROUND stmt exp . SEMICOL stmt R_ROUND stmt_blk
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         shift and go to state 118
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 108

    (35) stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .

    SEMICOL         reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    L_ROUND         reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    L_CURLY         reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    L_SQR           reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    PRINT           reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    FOR             reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    STRUCT          reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    VAR_NAME        reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    FUNC_DEC        reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    RETURN          reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    MINUS           reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    NOT             reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    INT             reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    FLOAT           reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    STRING          reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    CHAR            reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    BOOL            reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    IF              reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    DATA_TYPE       reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    $end            reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    R_CURLY         reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)
    R_ROUND         reduce using rule 35 (stmt -> VAR_NAME ASSIGNMENT exp SEMICOL .)


state 109

    (54) exp -> VAR_NAME L_ROUND args R_ROUND .

    SEMICOL         reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    ASSIGNMENT      reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    PLUS            reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    MINUS           reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    ASTERISK        reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    FWSLASH         reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    TOPI            reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    MOD             reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    LESSER          reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    GREATER         reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    LESSER_EQUAL    reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    GREATER_EQUAL   reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    IS_EQUAL        reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    NOT_EQUAL       reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    LOGICAL         reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    DOT             reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    R_ROUND         reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    R_CURLY         reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    R_SQR           reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)
    COMMA           reduce using rule 54 (exp -> VAR_NAME L_ROUND args R_ROUND .)


state 110

    (28) stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .

    SEMICOL         reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    L_ROUND         reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    L_CURLY         reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    L_SQR           reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    PRINT           reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    FOR             reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    STRUCT          reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    VAR_NAME        reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    FUNC_DEC        reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    RETURN          reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    MINUS           reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    NOT             reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    INT             reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    FLOAT           reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    STRING          reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    CHAR            reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    BOOL            reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    IF              reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    DATA_TYPE       reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    $end            reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    R_CURLY         reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)
    R_ROUND         reduce using rule 28 (stmt -> FUNC_DEC VAR_NAME param_blk stmt_blk .)


state 111

    (8) stmt_blk -> L_CURLY . S R_CURLY
    (1) S -> . stmt S
    (2) S -> .
    (3) stmt -> . exp SEMICOL
    (4) stmt -> . SEMICOL
    (5) stmt -> . L_ROUND R_ROUND
    (6) stmt -> . L_CURLY R_CURLY
    (7) stmt -> . L_SQR R_SQR
    (9) stmt -> . PRINT L_ROUND args R_ROUND SEMICOL
    (13) stmt -> . if
    (18) stmt -> . FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk
    (19) stmt -> . STRUCT VAR_NAME dec_blk
    (20) stmt -> . VAR_NAME VAR_NAME SEMICOL
    (21) stmt -> . declare
    (22) stmt -> . dec_blk
    (28) stmt -> . FUNC_DEC VAR_NAME param_blk stmt_blk
    (33) stmt -> . RETURN exp SEMICOL
    (34) stmt -> . RETURN SEMICOL
    (35) stmt -> . VAR_NAME ASSIGNMENT exp SEMICOL
    (36) stmt -> . exp ASSIGNMENT exp SEMICOL
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL
    (14) if -> . IF L_ROUND exp R_ROUND stmt_blk else
    (24) declare -> . dec declare
    (25) declare -> .
    (23) dec_blk -> . L_CURLY declare R_CURLY
    (26) dec -> . DATA_TYPE VAR_NAME SEMICOL
    (27) dec -> . DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL

  ! shift/reduce conflict for SEMICOL resolved as shift
  ! shift/reduce conflict for L_ROUND resolved as shift
  ! shift/reduce conflict for L_CURLY resolved as shift
  ! shift/reduce conflict for L_SQR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRUCT resolved as shift
  ! shift/reduce conflict for VAR_NAME resolved as shift
  ! shift/reduce conflict for FUNC_DEC resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for R_CURLY resolved using rule 2 (S -> .)
  ! shift/reduce conflict for DATA_TYPE resolved as shift
    R_CURLY         reduce using rule 2 (S -> .)
    SEMICOL         shift and go to state 4
    L_ROUND         shift and go to state 5
    L_CURLY         shift and go to state 6
    L_SQR           shift and go to state 7
    PRINT           shift and go to state 8
    FOR             shift and go to state 10
    STRUCT          shift and go to state 11
    VAR_NAME        shift and go to state 12
    FUNC_DEC        shift and go to state 15
    RETURN          shift and go to state 16
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23
    IF              shift and go to state 24
    DATA_TYPE       shift and go to state 26

  ! SEMICOL         [ reduce using rule 25 (declare -> .) ]
  ! L_ROUND         [ reduce using rule 25 (declare -> .) ]
  ! L_CURLY         [ reduce using rule 25 (declare -> .) ]
  ! L_SQR           [ reduce using rule 25 (declare -> .) ]
  ! PRINT           [ reduce using rule 25 (declare -> .) ]
  ! FOR             [ reduce using rule 25 (declare -> .) ]
  ! STRUCT          [ reduce using rule 25 (declare -> .) ]
  ! VAR_NAME        [ reduce using rule 25 (declare -> .) ]
  ! FUNC_DEC        [ reduce using rule 25 (declare -> .) ]
  ! RETURN          [ reduce using rule 25 (declare -> .) ]
  ! MINUS           [ reduce using rule 25 (declare -> .) ]
  ! NOT             [ reduce using rule 25 (declare -> .) ]
  ! INT             [ reduce using rule 25 (declare -> .) ]
  ! FLOAT           [ reduce using rule 25 (declare -> .) ]
  ! STRING          [ reduce using rule 25 (declare -> .) ]
  ! CHAR            [ reduce using rule 25 (declare -> .) ]
  ! BOOL            [ reduce using rule 25 (declare -> .) ]
  ! IF              [ reduce using rule 25 (declare -> .) ]
  ! DATA_TYPE       [ reduce using rule 25 (declare -> .) ]
  ! R_CURLY         [ reduce using rule 25 (declare -> .) ]

    S                              shift and go to state 119
    stmt                           shift and go to state 2
    exp                            shift and go to state 3
    if                             shift and go to state 9
    dec_blk                        shift and go to state 13
    declare                        shift and go to state 14
    dec                            shift and go to state 25

state 112

    (29) param_blk -> L_ROUND param . R_ROUND
    (30) param -> param . COMMA param

    R_ROUND         shift and go to state 120
    COMMA           shift and go to state 121


state 113

    (31) param -> DATA_TYPE . VAR_NAME

    VAR_NAME        shift and go to state 122


state 114

    (14) if -> IF L_ROUND exp R_ROUND . stmt_blk else
    (8) stmt_blk -> . L_CURLY S R_CURLY

    L_CURLY         shift and go to state 111

    stmt_blk                       shift and go to state 123

state 115

    (27) dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp . SEMICOL
    (40) exp -> exp . PLUS exp
    (41) exp -> exp . MINUS exp
    (42) exp -> exp . ASTERISK exp
    (43) exp -> exp . FWSLASH exp
    (44) exp -> exp . TOPI exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . LESSER exp
    (47) exp -> exp . GREATER exp
    (48) exp -> exp . LESSER_EQUAL exp
    (49) exp -> exp . GREATER_EQUAL exp
    (50) exp -> exp . IS_EQUAL exp
    (51) exp -> exp . NOT_EQUAL exp
    (52) exp -> exp . LOGICAL exp
    (53) exp -> exp . DOT VAR_NAME

    SEMICOL         shift and go to state 124
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    ASTERISK        shift and go to state 32
    FWSLASH         shift and go to state 33
    TOPI            shift and go to state 34
    MOD             shift and go to state 35
    LESSER          shift and go to state 36
    GREATER         shift and go to state 37
    LESSER_EQUAL    shift and go to state 38
    GREATER_EQUAL   shift and go to state 39
    IS_EQUAL        shift and go to state 40
    NOT_EQUAL       shift and go to state 41
    LOGICAL         shift and go to state 42
    DOT             shift and go to state 43


state 116

    (9) stmt -> PRINT L_ROUND args R_ROUND SEMICOL .

    SEMICOL         reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    L_ROUND         reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    L_CURLY         reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    L_SQR           reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    PRINT           reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    FOR             reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    STRUCT          reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    VAR_NAME        reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    FUNC_DEC        reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    RETURN          reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    MINUS           reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    NOT             reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    INT             reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    FLOAT           reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    STRING          reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    CHAR            reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    BOOL            reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    IF              reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    DATA_TYPE       reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    $end            reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    R_CURLY         reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)
    R_ROUND         reduce using rule 9 (stmt -> PRINT L_ROUND args R_ROUND SEMICOL .)


state 117

    (10) args -> args COMMA args .
    (10) args -> args . COMMA args

  ! shift/reduce conflict for COMMA resolved as shift
    R_ROUND         reduce using rule 10 (args -> args COMMA args .)
    COMMA           shift and go to state 106

  ! COMMA           [ reduce using rule 10 (args -> args COMMA args .) ]


state 118

    (18) stmt -> FOR L_ROUND stmt exp SEMICOL . stmt R_ROUND stmt_blk
    (3) stmt -> . exp SEMICOL
    (4) stmt -> . SEMICOL
    (5) stmt -> . L_ROUND R_ROUND
    (6) stmt -> . L_CURLY R_CURLY
    (7) stmt -> . L_SQR R_SQR
    (9) stmt -> . PRINT L_ROUND args R_ROUND SEMICOL
    (13) stmt -> . if
    (18) stmt -> . FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk
    (19) stmt -> . STRUCT VAR_NAME dec_blk
    (20) stmt -> . VAR_NAME VAR_NAME SEMICOL
    (21) stmt -> . declare
    (22) stmt -> . dec_blk
    (28) stmt -> . FUNC_DEC VAR_NAME param_blk stmt_blk
    (33) stmt -> . RETURN exp SEMICOL
    (34) stmt -> . RETURN SEMICOL
    (35) stmt -> . VAR_NAME ASSIGNMENT exp SEMICOL
    (36) stmt -> . exp ASSIGNMENT exp SEMICOL
    (37) exp -> . L_ROUND exp R_ROUND
    (38) exp -> . L_CURLY exp R_CURLY
    (39) exp -> . L_SQR exp R_SQR
    (40) exp -> . exp PLUS exp
    (41) exp -> . exp MINUS exp
    (42) exp -> . exp ASTERISK exp
    (43) exp -> . exp FWSLASH exp
    (44) exp -> . exp TOPI exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp LESSER exp
    (47) exp -> . exp GREATER exp
    (48) exp -> . exp LESSER_EQUAL exp
    (49) exp -> . exp GREATER_EQUAL exp
    (50) exp -> . exp IS_EQUAL exp
    (51) exp -> . exp NOT_EQUAL exp
    (52) exp -> . exp LOGICAL exp
    (53) exp -> . exp DOT VAR_NAME
    (54) exp -> . VAR_NAME L_ROUND args R_ROUND
    (55) exp -> . MINUS exp
    (56) exp -> . NOT exp
    (57) exp -> . VAR_NAME PLUS_PLUS
    (58) exp -> . VAR_NAME MINUS_MINUS
    (59) exp -> . VAR_NAME
    (60) exp -> . INT
    (61) exp -> . FLOAT
    (62) exp -> . STRING
    (63) exp -> . CHAR
    (64) exp -> . BOOL
    (14) if -> . IF L_ROUND exp R_ROUND stmt_blk else
    (24) declare -> . dec declare
    (25) declare -> .
    (23) dec_blk -> . L_CURLY declare R_CURLY
    (26) dec -> . DATA_TYPE VAR_NAME SEMICOL
    (27) dec -> . DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL

    SEMICOL         shift and go to state 4
    L_ROUND         shift and go to state 5
    L_CURLY         shift and go to state 6
    L_SQR           shift and go to state 7
    PRINT           shift and go to state 8
    FOR             shift and go to state 10
    STRUCT          shift and go to state 11
    VAR_NAME        shift and go to state 12
    FUNC_DEC        shift and go to state 15
    RETURN          shift and go to state 16
    MINUS           shift and go to state 17
    NOT             shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    CHAR            shift and go to state 22
    BOOL            shift and go to state 23
    IF              shift and go to state 24
    R_ROUND         reduce using rule 25 (declare -> .)
    DATA_TYPE       shift and go to state 26

    stmt                           shift and go to state 125
    exp                            shift and go to state 3
    if                             shift and go to state 9
    dec_blk                        shift and go to state 13
    declare                        shift and go to state 14
    dec                            shift and go to state 25

state 119

    (8) stmt_blk -> L_CURLY S . R_CURLY

    R_CURLY         shift and go to state 126


state 120

    (29) param_blk -> L_ROUND param R_ROUND .

    L_CURLY         reduce using rule 29 (param_blk -> L_ROUND param R_ROUND .)


state 121

    (30) param -> param COMMA . param
    (30) param -> . param COMMA param
    (31) param -> . DATA_TYPE VAR_NAME
    (32) param -> .

    DATA_TYPE       shift and go to state 113
    COMMA           reduce using rule 32 (param -> .)
    R_ROUND         reduce using rule 32 (param -> .)

    param                          shift and go to state 127

state 122

    (31) param -> DATA_TYPE VAR_NAME .

    R_ROUND         reduce using rule 31 (param -> DATA_TYPE VAR_NAME .)
    COMMA           reduce using rule 31 (param -> DATA_TYPE VAR_NAME .)


state 123

    (14) if -> IF L_ROUND exp R_ROUND stmt_blk . else
    (15) else -> . ELSE stmt_blk
    (16) else -> . ELSE if
    (17) else -> .

    ELSE            shift and go to state 129
    SEMICOL         reduce using rule 17 (else -> .)
    L_ROUND         reduce using rule 17 (else -> .)
    L_CURLY         reduce using rule 17 (else -> .)
    L_SQR           reduce using rule 17 (else -> .)
    PRINT           reduce using rule 17 (else -> .)
    FOR             reduce using rule 17 (else -> .)
    STRUCT          reduce using rule 17 (else -> .)
    VAR_NAME        reduce using rule 17 (else -> .)
    FUNC_DEC        reduce using rule 17 (else -> .)
    RETURN          reduce using rule 17 (else -> .)
    MINUS           reduce using rule 17 (else -> .)
    NOT             reduce using rule 17 (else -> .)
    INT             reduce using rule 17 (else -> .)
    FLOAT           reduce using rule 17 (else -> .)
    STRING          reduce using rule 17 (else -> .)
    CHAR            reduce using rule 17 (else -> .)
    BOOL            reduce using rule 17 (else -> .)
    IF              reduce using rule 17 (else -> .)
    DATA_TYPE       reduce using rule 17 (else -> .)
    $end            reduce using rule 17 (else -> .)
    R_CURLY         reduce using rule 17 (else -> .)
    R_ROUND         reduce using rule 17 (else -> .)

    else                           shift and go to state 128

state 124

    (27) dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .

    DATA_TYPE       reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    SEMICOL         reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    L_ROUND         reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    L_CURLY         reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    L_SQR           reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    PRINT           reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    FOR             reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    STRUCT          reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    VAR_NAME        reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    FUNC_DEC        reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    RETURN          reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    MINUS           reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    NOT             reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    INT             reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    FLOAT           reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    STRING          reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    CHAR            reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    BOOL            reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    IF              reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    $end            reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    R_CURLY         reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)
    R_ROUND         reduce using rule 27 (dec -> DATA_TYPE VAR_NAME ASSIGNMENT exp SEMICOL .)


state 125

    (18) stmt -> FOR L_ROUND stmt exp SEMICOL stmt . R_ROUND stmt_blk

    R_ROUND         shift and go to state 130


state 126

    (8) stmt_blk -> L_CURLY S R_CURLY .

    SEMICOL         reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    L_ROUND         reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    L_CURLY         reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    L_SQR           reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    PRINT           reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    FOR             reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    STRUCT          reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    VAR_NAME        reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    FUNC_DEC        reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    RETURN          reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    MINUS           reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    NOT             reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    INT             reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    FLOAT           reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    STRING          reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    CHAR            reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    BOOL            reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    IF              reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    DATA_TYPE       reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    $end            reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    R_CURLY         reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    R_ROUND         reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)
    ELSE            reduce using rule 8 (stmt_blk -> L_CURLY S R_CURLY .)


state 127

    (30) param -> param COMMA param .
    (30) param -> param . COMMA param

  ! shift/reduce conflict for COMMA resolved as shift
    R_ROUND         reduce using rule 30 (param -> param COMMA param .)
    COMMA           shift and go to state 121

  ! COMMA           [ reduce using rule 30 (param -> param COMMA param .) ]


state 128

    (14) if -> IF L_ROUND exp R_ROUND stmt_blk else .

    SEMICOL         reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    L_ROUND         reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    L_CURLY         reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    L_SQR           reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    PRINT           reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    FOR             reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    STRUCT          reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    VAR_NAME        reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    FUNC_DEC        reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    RETURN          reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    MINUS           reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    NOT             reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    INT             reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    FLOAT           reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    STRING          reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    CHAR            reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    BOOL            reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    IF              reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    DATA_TYPE       reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    $end            reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    R_CURLY         reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)
    R_ROUND         reduce using rule 14 (if -> IF L_ROUND exp R_ROUND stmt_blk else .)


state 129

    (15) else -> ELSE . stmt_blk
    (16) else -> ELSE . if
    (8) stmt_blk -> . L_CURLY S R_CURLY
    (14) if -> . IF L_ROUND exp R_ROUND stmt_blk else

    L_CURLY         shift and go to state 111
    IF              shift and go to state 24

    stmt_blk                       shift and go to state 131
    if                             shift and go to state 132

state 130

    (18) stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND . stmt_blk
    (8) stmt_blk -> . L_CURLY S R_CURLY

    L_CURLY         shift and go to state 111

    stmt_blk                       shift and go to state 133

state 131

    (15) else -> ELSE stmt_blk .

    SEMICOL         reduce using rule 15 (else -> ELSE stmt_blk .)
    L_ROUND         reduce using rule 15 (else -> ELSE stmt_blk .)
    L_CURLY         reduce using rule 15 (else -> ELSE stmt_blk .)
    L_SQR           reduce using rule 15 (else -> ELSE stmt_blk .)
    PRINT           reduce using rule 15 (else -> ELSE stmt_blk .)
    FOR             reduce using rule 15 (else -> ELSE stmt_blk .)
    STRUCT          reduce using rule 15 (else -> ELSE stmt_blk .)
    VAR_NAME        reduce using rule 15 (else -> ELSE stmt_blk .)
    FUNC_DEC        reduce using rule 15 (else -> ELSE stmt_blk .)
    RETURN          reduce using rule 15 (else -> ELSE stmt_blk .)
    MINUS           reduce using rule 15 (else -> ELSE stmt_blk .)
    NOT             reduce using rule 15 (else -> ELSE stmt_blk .)
    INT             reduce using rule 15 (else -> ELSE stmt_blk .)
    FLOAT           reduce using rule 15 (else -> ELSE stmt_blk .)
    STRING          reduce using rule 15 (else -> ELSE stmt_blk .)
    CHAR            reduce using rule 15 (else -> ELSE stmt_blk .)
    BOOL            reduce using rule 15 (else -> ELSE stmt_blk .)
    IF              reduce using rule 15 (else -> ELSE stmt_blk .)
    DATA_TYPE       reduce using rule 15 (else -> ELSE stmt_blk .)
    $end            reduce using rule 15 (else -> ELSE stmt_blk .)
    R_CURLY         reduce using rule 15 (else -> ELSE stmt_blk .)
    R_ROUND         reduce using rule 15 (else -> ELSE stmt_blk .)


state 132

    (16) else -> ELSE if .

    SEMICOL         reduce using rule 16 (else -> ELSE if .)
    L_ROUND         reduce using rule 16 (else -> ELSE if .)
    L_CURLY         reduce using rule 16 (else -> ELSE if .)
    L_SQR           reduce using rule 16 (else -> ELSE if .)
    PRINT           reduce using rule 16 (else -> ELSE if .)
    FOR             reduce using rule 16 (else -> ELSE if .)
    STRUCT          reduce using rule 16 (else -> ELSE if .)
    VAR_NAME        reduce using rule 16 (else -> ELSE if .)
    FUNC_DEC        reduce using rule 16 (else -> ELSE if .)
    RETURN          reduce using rule 16 (else -> ELSE if .)
    MINUS           reduce using rule 16 (else -> ELSE if .)
    NOT             reduce using rule 16 (else -> ELSE if .)
    INT             reduce using rule 16 (else -> ELSE if .)
    FLOAT           reduce using rule 16 (else -> ELSE if .)
    STRING          reduce using rule 16 (else -> ELSE if .)
    CHAR            reduce using rule 16 (else -> ELSE if .)
    BOOL            reduce using rule 16 (else -> ELSE if .)
    IF              reduce using rule 16 (else -> ELSE if .)
    DATA_TYPE       reduce using rule 16 (else -> ELSE if .)
    $end            reduce using rule 16 (else -> ELSE if .)
    R_CURLY         reduce using rule 16 (else -> ELSE if .)
    R_ROUND         reduce using rule 16 (else -> ELSE if .)


state 133

    (18) stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .

    SEMICOL         reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    L_ROUND         reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    L_CURLY         reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    L_SQR           reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    PRINT           reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    FOR             reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    STRUCT          reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    VAR_NAME        reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    FUNC_DEC        reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    RETURN          reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    MINUS           reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    NOT             reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    INT             reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    FLOAT           reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    STRING          reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    CHAR            reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    BOOL            reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    IF              reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    DATA_TYPE       reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    $end            reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    R_CURLY         reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)
    R_ROUND         reduce using rule 18 (stmt -> FOR L_ROUND stmt exp SEMICOL stmt R_ROUND stmt_blk .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOL in state 0 resolved as shift
WARNING: shift/reduce conflict for L_ROUND in state 0 resolved as shift
WARNING: shift/reduce conflict for L_CURLY in state 0 resolved as shift
WARNING: shift/reduce conflict for L_SQR in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for STRUCT in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR_NAME in state 0 resolved as shift
WARNING: shift/reduce conflict for FUNC_DEC in state 0 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for DATA_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for SEMICOL in state 2 resolved as shift
WARNING: shift/reduce conflict for L_ROUND in state 2 resolved as shift
WARNING: shift/reduce conflict for L_CURLY in state 2 resolved as shift
WARNING: shift/reduce conflict for L_SQR in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for STRUCT in state 2 resolved as shift
WARNING: shift/reduce conflict for VAR_NAME in state 2 resolved as shift
WARNING: shift/reduce conflict for FUNC_DEC in state 2 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 2 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 2 resolved as shift
WARNING: shift/reduce conflict for NOT in state 2 resolved as shift
WARNING: shift/reduce conflict for INT in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for STRING in state 2 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for DATA_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for R_CURLY in state 6 resolved as shift
WARNING: shift/reduce conflict for ASSIGNMENT in state 12 resolved as shift
WARNING: shift/reduce conflict for DATA_TYPE in state 25 resolved as shift
WARNING: shift/reduce conflict for L_ROUND in state 56 resolved as shift
WARNING: shift/reduce conflict for L_CURLY in state 56 resolved as shift
WARNING: shift/reduce conflict for L_SQR in state 56 resolved as shift
WARNING: shift/reduce conflict for VAR_NAME in state 56 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 56 resolved as shift
WARNING: shift/reduce conflict for NOT in state 56 resolved as shift
WARNING: shift/reduce conflict for INT in state 56 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 56 resolved as shift
WARNING: shift/reduce conflict for STRING in state 56 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 56 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 56 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 67 resolved as shift
WARNING: shift/reduce conflict for FWSLASH in state 67 resolved as shift
WARNING: shift/reduce conflict for TOPI in state 67 resolved as shift
WARNING: shift/reduce conflict for MOD in state 67 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 67 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 67 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for IS_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for LOGICAL in state 67 resolved as shift
WARNING: shift/reduce conflict for DOT in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 84 resolved as shift
WARNING: shift/reduce conflict for FWSLASH in state 84 resolved as shift
WARNING: shift/reduce conflict for TOPI in state 84 resolved as shift
WARNING: shift/reduce conflict for MOD in state 84 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 84 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 84 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for IS_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for LOGICAL in state 84 resolved as shift
WARNING: shift/reduce conflict for DOT in state 84 resolved as shift
WARNING: shift/reduce conflict for SEMICOL in state 111 resolved as shift
WARNING: shift/reduce conflict for L_ROUND in state 111 resolved as shift
WARNING: shift/reduce conflict for L_CURLY in state 111 resolved as shift
WARNING: shift/reduce conflict for L_SQR in state 111 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 111 resolved as shift
WARNING: shift/reduce conflict for FOR in state 111 resolved as shift
WARNING: shift/reduce conflict for STRUCT in state 111 resolved as shift
WARNING: shift/reduce conflict for VAR_NAME in state 111 resolved as shift
WARNING: shift/reduce conflict for FUNC_DEC in state 111 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for NOT in state 111 resolved as shift
WARNING: shift/reduce conflict for INT in state 111 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 111 resolved as shift
WARNING: shift/reduce conflict for STRING in state 111 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 111 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 111 resolved as shift
WARNING: shift/reduce conflict for IF in state 111 resolved as shift
WARNING: shift/reduce conflict for DATA_TYPE in state 111 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 117 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 127 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (S -> <empty>)
WARNING: rejected rule (declare -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 2 resolved using rule (S -> <empty>)
WARNING: rejected rule (declare -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 111 resolved using rule (S -> <empty>)
WARNING: rejected rule (declare -> <empty>) in state 111
